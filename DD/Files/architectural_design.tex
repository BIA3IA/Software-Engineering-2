% --------------------------------------------------------------------------
% Architectural Design
% --------------------------------------------------------------------------

\section{Architectural Overview: High-level components and their interactions}
\label{sec:overview}%

The architecture of the Best Bike Paths (BBP) system follows a classic
\textbf{three-tier structure}, separating the software into a presentation layer,
an app layer, and a data layer. This architectural style ensures a clear
division of responsibilities and simplifies the evolution of the system over time.
Since BBP is conceived as a mobile-centric platform, the presentation tier is
implemented entirely through the BBP mobile app, which communicates with
the backend via RESTful APIs over HTTPS.

\subsection*{Presentation Layer}

The presentation layer consists solely of the \textbf{BBP mobile app},
which serves as the primary interface between users and the system.
This layer is responsible for:
\begin{itemize}
	\item rendering the user interface and handling user interactions;
	\item acquiring device-level data (GPS, accelerometer, gyroscope) during trips;
	\item displaying bike paths, trip summaries, statistics, and reports;
	\item invoking backend functionalities through HTTP requests.
\end{itemize}

The mobile app is intentionally designed as a \textbf{thin client}.
All domain logic, decision processes, ranking operations, and aggregation of path
information are delegated to the application layer.
The app interacts with device-level subsystems such as the GPS module
and external sensors (when available), but these elements are not part of the backend architecture.
The mobile app also uses the secure storage facilities provided by the operating system
(iOS Keychain / Android Keystore) to safely store authentication tokens and other sensitive data.

\subsection*{Application Layer}

The application layer embodies the \textbf{core business logic} of BBP.
It is implemented as a modular backend composed of independent yet cooperating \textbf{components},
each encapsulating a well-defined responsibility.
These components are logically independent in terms of responsibilities and interfaces,
but they are part of a single backend app.
The main functional components include:

\begin{itemize}
	\item \textbf{User Module}: contains the \textbf{AuthManager} and the
	      \textbf{UserManager}, responsible for authentication, credential verification,
	      and management of user profiles.
	\item \textbf{TripManager}: handles
	      the lifecycle of a cycling trip and produces trip summaries enriched with
	      contextual weather data.
	\item \textbf{PathManager}:  responsible for
	      maintaining bike-path data, computing routes, and ranking candidate paths according to
	      their condition and effectiveness.
	\item \textbf{ReportManager}: responsible
	      for storing and aggregating reports, managing confirmations, and updating
	      path-condition indicators.
	\item \textbf{StatsManager}: computes and stores user statistics and per-trip metrics.
	\item \textbf{WeatherManager}: interfaces with an external weather service to retrieve
	      meteorological data.
\end{itemize}

All modules are accessed through the \textbf{API Gateway}, which exposes a set of
RESTful sub-APIs and routes incoming requests to the appropriate Manager.

\subsection*{Data Layer}

The data layer consists of a \textbf{relational DBMS} storing all persistent
information relevant to the system's domain, including:
\begin{itemize}
	\item user profiles and authentication credentials;
	\item trip records and associated GPS data;
	\item bike path segments and their aggregated conditions;
	\item reports, confirmations, and metadata about obstacles;
	\item computed statistics and weather snapshot.
\end{itemize}

All interactions with the DBMS are mediated by a single \textbf{QueryManager},
which centralises data-access operations and offers a uniform interface for
executing queries. This design keeps persistence concerns separated from the
application logic and reduces duplication across components.

% --------------------------------------------------------------------------
% Component View
% --------------------------------------------------------------------------

\section{Component View}
\label{sec:component_view}

This section describes the main software components that constitute the BBP backend
and their responsibilities. As required by the three-tier architecture adopted by the system,
the backend is structured into a set of independent yet cooperating modules, each exposing
well-defined interfaces and encapsulating a cohesive subset of the app logic.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Architectural_Overview/component_view.png}
	\caption{Component View Diagram}
	\label{fig:component_view}
\end{figure}

\subsubsection{API Gateway}
The \textbf{API Gateway} acts as the entry point for all interactions between the BBP mobile
app and the backend. It is responsible for routing incoming requests to the appropriate
internal services, enforcing authentication and authorization requirements, validating inputs,
and translating domain errors into HTTP responses.

The API Gateway exposes the following logical sub-APIs:
\begin{itemize}
	\item \textbf{AuthAPI}: endpoints for login, token generation and validation.
	\item \textbf{UserAPI}: endpoints for registration, token refresh, and profile retrieval.
	\item \textbf{TripAPI}: endpoints for starting, updating, and stopping a trip.
	\item \textbf{PathAPI}: endpoints for route computation and retrieval of path metadata.
	\item \textbf{ReportAPI}: endpoints for creating and confirming obstacle reports.
	\item \textbf{StatisticsAPI}: endpoints for retrieving per-trip and aggregated statistics.
\end{itemize}

\subsubsection{User Module}
The \textbf{User Module} groups two Managers:
\begin{itemize}
	\item \textbf{AuthManager}, responsible for authentication and token issuance.
	\item \textbf{UserManager}, responsible for registration and profile updates.
\end{itemize}
Both Managers use the \textbf{QueryManager} for data retrieval and persistence.

\subsubsection{Trip Manager}
The \textbf{TripManager} coordinates the lifecycle of a cycling session.
GPS samples and live tracking stay on the mobile app during the trip; the backend is contacted only at stop time.
Upon trip completion, the app sends the final payload (trajectory, metrics) to the backend.
The TripManager generates the summary, enriches it with environmental data retrieved from the \textbf{WeatherManager},
and persists it through the \textbf{QueryManager}.

\subsubsection{Path Manager}
The \textbf{PathManager} is responsible for retrieving graph
data from the database, computing optimal routes between two locations,
and ranking alternative routes according to their quality and reported conditions.
This service exposes the routing logic to the API Gateway and interacts with the
\textbf{QueryManager} to retrieve pre-aggregated segment conditions alongside path data needed for route computation.

\subsubsection{Report Manager}
The \textbf{ReportManager} handles obstacle reports submitted
by users or automatically detected during trips. It stores and aggregates reports, manages
confirmation and rejection flows, updates path-quality indicators, and exposes relevant data to the mobile app.
This component interacts with the \textbf{QueryManager} for persistence and with the
Routing \& Path Manager when updated conditions affect route evaluation.

\subsubsection{Statistics Manager}
The \textbf{Statistics Manager} optimizes system performance by using a state-aware recomputation strategy that minimizes redundant processing.
For overall statistics, it compares the user's current total trip count against the value stored from the last calculation; it only triggers a full
aggregation of data if the \textbf{QueryManager} reports a change in the trip count, otherwise it simply retrieves the previously stored results.

For individual trip statistics, the manager utilizes a lazy initialization pattern by asking the \textbf{QueryManager} if a processed record already
exists for a specific trip ID. If the statistics are found, they are returned immediately; if not, the manager computes and persists them for the first time.
This dual-layered approach ensures that data is only processed when necessary, effectively eliminating double computations by relying on the \textbf{QueryManager}
to track the state of processed data.

\subsubsection{Weather Manager}
The \textbf{Weather Manager} interacts with the external weather API to obtain
meteorological information. It provides a weather snapshot associated with trip start and end points.
The snapshot is returned to the \textbf{TripManager}, which includes it in the final trip payload saved through the \textbf{QueryManager}.

\subsubsection{QueryManager}
The \textbf{QueryManager} is the data-access component of the backend.
It acts as the single entry point for interacting with the relational DBMS and
provides a set of methods to retrieve, insert, update, and delete domain data.
Centralising data access in one component simplifies consistency checks, reduces duplicated logic, and
keeps the domain layer independent of database details.

% --------------------------------------------------------------------------
% Deployment View
% --------------------------------------------------------------------------

\section{Deployment View}
\label{sec:deployment_view}%

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{../Images/deployment_view/deployment_view.png}
	\caption{Deployment View of the BBP System}
	\label{fig:deployment_view}
\end{figure}

The deployment view describes the hardware and software infrastructure supporting the \textit{BBP} system. Each tier is
executed on dedicated hardware nodes and communicates with the others using secure protocols.

\begin{itemize}
	\item \textbf{Presentation Tier:}
	      this tier includes all devices through which end users interact with the BBP system.
	      The primary clients are smartphones or tablets running iOS or Android, where the BBP mobile application is installed.
	      These devices communicate with the backend exclusively via HTTPS, ensuring confidentiality and data integrity.
	      While the client executes local presentation logic, no security-critical or authoritative business logic is enforced at this level.
	      The devices capture user input and location, display results, and forward authenticated or unauthenticated HTTPS requests
	      toward the Application Tier.

	\item \textbf{Application Tier:}
	      this tier is responsible for handling incoming traffic, enforcing security, applying routing and load balancing policies, and
	      executing the core business logic of the system.
	      All external requests first pass through a Linux-based node configured as a Web Application Firewall using \textit{ModSecurity},
	      enabling Layer-7 inspection and protection.
	      ModSecurity blocks malicious traffic such as SQL injection attempts, cross-site scripting payloads, and abnormal request patterns,
	      while supporting anomaly detection.
	      TLS termination is performed at the WAF to allow full request inspection; validated traffic is re-encrypted and forwarded to the internal
	      internal \textit{NGINX} gateway over HTTPS.
	      NGINX acts as the system's reverse proxy and load balancer, exposing a single controlled entrypoint and distributing incoming
	      requests across multiple backend replicas using load balancing strategies.
	      Additional middleware functionalities (request logging or rate limiting) can be applied as needed at this level.
	      The backend application itself is executed on one or more stateless Application Servers, each running the BBP RESTful backend.
	      Since authentication tokens are included in each request header, no server-side session state is maintained, enabling horizontal
	      scaling and dynamic replica management.
	      Communication between the gateway and the backend replicas is confined to a protected internal network, reducing the system's
	      exposure to external threats.

	\item \textbf{Data Tier:}
	      the Data Tier consists of a dedicated server running a PostgreSQL database instance, which stores all persistent system data
	      such as user information, paths, trips, and analytics.
	      Backend servers interact with the database over TCP/IP within an isolated internal network segment, typically via standard
	      PostgreSQL drivers and the \textit{Prisma} ORM running on the Application Servers.
	      Centralizing the database simplifies backup strategies, consistency enforcement, and maintenance operations, while still
	      allowing for potential future extensions such as replication or clustering without altering the upper tiers of the system.

\end{itemize}

% --------------------------------------------------------------------------
% Runtime View
% --------------------------------------------------------------------------

\section{Runtime View}
\label{sec:runtime_view}%

The Runtime View describes how the components of the BBP system collaborate
to realise the behaviour specified in the functional requirements.
While the Component View focuses on the static organisation of the backend,
the Runtime View illustrates how these components interact dynamically
during the execution of the main use cases.

All diagrams follow the modular structure of the backend:
the mobile client invokes the \textbf{API Gateway}, which routes each request to the
appropriate \textbf{Manager}.
Persistence operations are centralised in the \textbf{QueryManager}, whereas
weather-related data requests involve the \textbf{WeatherManager} and its external API.

The sequence diagrams that follow cover the core use cases and show how responsibilities
are distributed at runtime.

\subsubsection*{[UC1] - User Registration}

A new user wants to register into the BBP system.
The process begins on the mobile app, where the guest user opens the registration page,
and fills in the required details: email and password.
A first \textbf{local validation} step checks for malformed inputs before contacting the \textbf{backend}.

If the data is valid, the mobile app sends a registration request to the \textbf{API Gateway}, which forwards it to the \textbf{UserManager}.
The \textbf{UserManager} checks whether the email is already in use by querying the DBMS through the \textbf{QueryManager}.
If the email already exists, the system returns an error and the mobile app notifies the user.

If the email is not already in use, the \textbf{UserManager} stores the new user in the database (with the password handled securely).
The flow ends by showing a success message to the user.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_registration.png}
	\caption{User Registration Sequence Diagram}
	\label{fig:use_case_user_registration}
\end{figure}
\pagebreak

\subsubsection*{[UC2] - User Log In}

A guest user wants to authenticate and obtain access to the system. The process starts
when the user opens the login form and submits credentials through the mobile app. After
a \textbf{local validation}, the app sends an HTTP request to the login endpoint exposed by the \textbf{API Gateway}.

The \textbf{API Gateway} forwards the request to the \textbf{AuthManager}, which first checks whether the provided
email exists by querying the \textbf{DBMS} through the \textbf{QueryManager}. If the email is not found,
the backend returns a \textbf{404 Not Found} error, which the mobile app displays to the user.
If the user exists, the \textbf{AuthManager} verifies the submitted password. Invalid credentials
lead to a \textbf{401 Unauthorized} response and the corresponding error message on the client.

When the credentials are correct, the \textbf{AuthManager} generates an \textbf{authentication token} and a \textbf{refresh token},
returns them to the mobile app, which stores them securely using the device's
\textbf{secure storage} facility. The user is then successfully logged in and the app
proceeds to show the appropriate authenticated UI.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_login.png}
	\caption{User Log In Sequence Diagram}
	\label{fig:use_case_user_login}
\end{figure}
\pagebreak

\subsubsection*{[UC3] - User Log Out}

When a logged-in user initiates the logout operation from the mobile app, the client first removes the locally
stored tokens from the device's \textbf{secure storage}. This ensures the user is logged out on the client side
even if the network request fails.

After clearing local data, the mobile app sends an HTTP request to the logout endpoint exposed by the \textbf{API Gateway}.
The \textbf{API Gateway} forwards the request to the \textbf{AuthManager}, which invalidates the current session by deleting
the corresponding \textbf{refresh token} through the \textbf{QueryManager}. The \textbf{QueryManager} executes a
\textbf{DELETE} operation on the database to remove the stored token.

If the operation succeeds, the server returns a \textbf{204 NO\_CONTENT} response and the app shows a success message.
If a network or server error occurs (timeout or \textbf{5xx}), the flow is interrupted and the mobile app shows a
\textbf{“Network unavailable”} error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_logout.png}
	\caption{User Log Out Sequence Diagram}
	\label{fig:use_case_user_logout}
\end{figure}
\pagebreak

\subsubsection*{[UC4] - Edit Personal Profile}

After the logged-in user opens the edit form, the mobile app
locally validates the submitted fields. If the data is incomplete or invalid,
the app immediately notifies the user. If the input is valid, the updated
payload is sent to the \textbf{API Gateway}, which delegates the request to the \textbf{UserManager}.

The update is forwarded to the \textbf{QueryManager}, which issues the corresponding \textbf{UPDATE} operation on the database.
If the update succeeds, the modified user profile is returned to the app and displayed to the user.

In case of network or server errors during the request, the mobile app shows an appropriate error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/edit_profile.png}
	\caption{Edit Personal Profile Sequence Diagram}
	\label{fig:use_case_edit_profile}
\end{figure}
\pagebreak

\subsubsection*{[UC5] - Search for a Path}

A user searches for bike paths between two locations by providing a starting point and a destination
through the mobile app. Before contacting the backend, the app performs a \textbf{local validation}
to ensure that the input data is complete and well-formed. If the validation fails, the user is
immediately notified.

When the input is valid, the mobile app sends a search request to the backend through the
\textbf{API Gateway}. The API Gateway forwards the request to the \textbf{PathManager}, which is
responsible for path computation.
The \textbf{PathManager} retrieves the relevant path segments and related information from the
database by interacting with the \textbf{QueryManager}. Once the data is available, it computes
the best path or set of paths according to the system criteria and user constraints.

If one or more valid routes are found, the \textbf{PathManager} returns the results to the
\textbf{API Gateway}, which responds to the mobile app with a \textbf{200 OK} message containing
the suggested paths. The app then displays the available routes to the user.
If no suitable route can be computed, the \textbf{PathManager} signals a \textbf{NO\_ROUTE}
condition, resulting in a \textbf{404} response that is propagated back to the mobile app,
which notifies the user accordingly.

In the event of network failures or server-side errors, the interaction is interrupted and
the mobile app shows a generic “Network unavailable” error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/search_path.png}
	\caption{Search for a Path Sequence Diagram}
	\label{fig:use_case_search_path}
\end{figure}
\pagebreak

\subsubsection*{[UC6] - Select a Path}

After receiving a list of suggested routes, the user can select a specific path to
inspect its details. When the user selects a path, the mobile app sends a request
containing the selected path identifier to the backend through the \textbf{API Gateway}.

The \textbf{API Gateway} forwards the request to the \textbf{PathManager}, which retrieves
the corresponding path information by querying the database through the
\textbf{QueryManager}.

If the path exists, the PathManager returns the path details to the API Gateway,
which responds with a \textbf{200 OK} status and forwards the information to the mobile app.
The app then displays the path details to the user.

If the path identifier does not correspond to any stored record, the PathManager
returns a \textbf{NOT\_FOUND} condition, resulting in a \textbf{404 Not Found} response.
The mobile app informs the user that the selected path is unavailable. Network or
server failures are handled consistently with other interactions.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\textwidth]{Images/Sequence_Diagrams/select_path.png}
	\caption{Select a Path Sequence Diagram}
	\label{fig:use_case_select_path}
\end{figure}
\pagebreak

\subsubsection*{[UC7] - Create a Path in Manual Mode}

When a logged-in user decides to create a new path, the interaction starts by opening
the path creation page in the mobile app. The user is first asked to provide the required
metadata and to select the \textbf{manual creation mode}. Once the metadata is submitted,
the mobile app performs an initial \textbf{local validation}.

If the metadata is invalid or incomplete, the app immediately notifies the user.
Otherwise, the app displays an interactive map that allows the user to manually draw
the path by defining its segments.
After the drawing phase, the user submits the generated segments.
Then, the mobile app sends a \textbf{POST} request to the backend through the \textbf{API Gateway}.
The gateway forwards the request to the \textbf{PathManager}, which handles the creation logic.

The PathManager delegates the persistence of the new path to the \textbf{QueryManager},
which executes the corresponding \textbf{INSERT} operation on the \textbf{DBMS}, associating
the path with the authenticated user.
Upon successful insertion, the PathManager returns the generated path identifier to the
API Gateway, which responds with a \textbf{201 Created} status. The mobile app receives
the response and displays a confirmation message indicating that the path has been
successfully created. In case of network or server errors, the app notifies the user
accordingly.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/create_manual.png}
	\caption{Create a Path in Manual Mode Sequence Diagram}
	\label{fig:use_case_create_path_manual}
\end{figure}
\pagebreak

\subsubsection*{[UC8] - Create a Path in Automatic Mode}

When a logged-in user chooses to create a new path in \textbf{automatic mode}, the
mobile app first displays a form to collect the required metadata and performs a
preliminary \textbf{local validation}. If the validation fails, the user is immediately
notified.

Once the input is valid, the app attempts to activate \textbf{GPS tracking}. If GPS
activation fails due to permission or hardware issues, the app displays an error
message and the procedure is interrupted.
If GPS tracking is successfully activated, the \textbf{GPS module} continuously provides
location samples (latitude, longitude, speed, timestamp) while the user is moving.
The mobile app locally stores these samples throughout the tracking session.

If a GPS signal error occurs during movement, the app detects the issue, interrupts
the process, and informs the user. When the user completes the recording session,
GPS tracking is deactivated and the collected samples undergo a final \textbf{local
	validation}. If the data is invalid, the user is notified.

If both metadata and recorded samples are valid, the mobile app sends a \textbf{POST}
request to the backend through the \textbf{API Gateway}. The gateway forwards the request
to the \textbf{PathManager}, which stores the new path by delegating persistence to the
\textbf{QueryManager}.
After the path is successfully inserted into the \textbf{DBMS}, the PathManager returns
the generated path identifier to the API Gateway, which responds with a
\textbf{201 Created} status. The mobile app then displays a success message confirming
that the automatically generated path has been saved.

Network or server failures are handled consistently with other interactions.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/create_automatic.png}
	\caption{Create a Path in Automatic Mode Sequence Diagram}
	\label{fig:use_case_create_path_automatic}
\end{figure}
\pagebreak

\subsubsection*{[UC9] - View Path Library}

A logged-in user wants to view the list of paths previously created.
The interaction starts when the user opens the personal path library section
in the mobile application. The app sends a request to the backend through the
\textbf{API Gateway} to retrieve all paths associated with the authenticated user.
The \textbf{API Gateway} forwards the request to the \textbf{PathManager},
which retrieves the list of paths owned by the user by querying the database
through the \textbf{QueryManager}. The QueryManager executes the corresponding
\textbf{SELECT} operation on the \textbf{DBMS}.

If one or more paths are found, the list is returned to the mobile app and
displayed to the user. If no paths exist for the given user, the backend returns
a \textbf{404 NOT\_FOUND} response, and the mobile app notifies the user that
no paths are available.
In case of network or server errors, the request is interrupted and the
mobile app displays an appropriate error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/path_library.png}
	\caption{View Path Library Sequence Diagram}
	\label{fig:use_case_view_path_library}
\end{figure}
\pagebreak

\subsubsection*{[UC10] - Manage Path Visibility}

A logged-in user wants to change the visibility of one of his previously created paths.
The interaction begins when the user selects a path and requests a visibility update
from the mobile application. The app sends a \textbf{PUT} request to the backend
through the \textbf{API Gateway}, specifying the desired visibility value.

The \textbf{API Gateway} forwards the request to the \textbf{PathManager},
which first verifies that the requesting user is the owner of the selected path.
This ownership check is performed by querying the database through the
\textbf{QueryManager}. If the path does not exist, the backend returns a
\textbf{404 NOT\_FOUND} response. If the user is not the owner, a
\textbf{403 FORBIDDEN} response is generated.

If the ownership verification succeeds, the \textbf{PathManager} updates the
visibility attribute of the path by issuing an \textbf{UPDATE} operation
through the \textbf{QueryManager}. Upon successful completion, the backend
returns a \textbf{200 OK} response, and the mobile app confirms the update to the user.
Network or server-side errors result in the interruption of the flow and the
display of an appropriate error message on the client.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/manage_visibility.png}
	\caption{Manage Path Visibility Sequence Diagram}
	\label{fig:use_case_manage_visibility}
\end{figure}
\pagebreak

\subsubsection*{[UC11] - Delete a Path}

When a logged-in user wants to permanently delete one of his paths,
he first selects a path to delete from the mobile
application. The app sends a \textbf{DELETE} request to the backend through the
\textbf{API Gateway}.

The \textbf{API Gateway} forwards the request to the \textbf{PathManager},
which first verifies that the path exists and that the requesting user is its owner.
This verification is performed by querying the database through the
\textbf{QueryManager}. If the path does not exist, a \textbf{404 NOT\_FOUND} response
is generated. If the user is not authorised to delete the path, the backend returns
a \textbf{403 FORBIDDEN} response.

If the ownership check succeeds, the \textbf{PathManager} performs the deletion
by issuing a cascade delete operation through the \textbf{QueryManager},
which removes the path from the \textbf{DBMS}. Upon successful deletion,
the backend returns a \textbf{204 NO\_CONTENT} response.
The mobile app then confirms the successful removal of the path to the user.
If a network or server error occurs during the process, the app displays
a corresponding error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/delete_path.png}
	\caption{Delete a Path Sequence Diagram}
	\label{fig:use_case_delete_path}
\end{figure}
\pagebreak

\subsubsection*{[UC12] - Start a Trip as Guest User}

When a guest user starts a trip using the BBP mobile app, he first selects a path
from the available options. The mobile app displays the selected path on the map
and attempts to activate \textbf{GPS tracking} to monitor the user's movement.
If GPS activation fails, the mobile app immediately notifies the user with an
appropriate error message. If activation succeeds, the app continuously receives
position updates from the \textbf{GPS module} while the user is moving and updates
the map accordingly.

If at any point the GPS signal is lost, the GPS module reports the error and the
mobile app displays a corresponding warning to the user, interrupting the normal
tracking flow.
No interaction with the backend occurs in this use case. Guest trips are not
associated with a persistent trip identifier and are not stored by the system.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_guest.png}
	\caption{Start a Trip as Guest User Sequence Diagram}
	\label{fig:use_case_start_trip_guest}
\end{figure}
\pagebreak

\subsubsection*{[UC13] - Start a Trip in Manual Mode as a Logged-in User}

In this scenario, a logged-in user starts a trip by selecting a path from the mobile app.
The selected path is displayed on the map, and the user is prompted to enable
\textbf{automatic mode}. The user explicitly declines this option, choosing to
proceed in manual mode.
The mobile app then attempts to activate the \textbf{GPS module}. If GPS activation
fails, the app immediately notifies the user with an error message. Otherwise, GPS
tracking starts and the device periodically provides position updates, including
latitude, longitude, speed, and timestamp.

During the trip, the mobile app stores the collected samples locally and updates the
map in real time. A trip identifier is generated and maintained locally by the app
during tracking and is not sent to the backend at this stage.
If the GPS signal is lost at any point, the GPS module reports the error and the mobile
app displays a corresponding warning to the user, interrupting the tracking process.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_manual.png}
	\caption{Start a Trip in Manual Mode as a Logged-in User Sequence Diagram}
	\label{fig:use_case_start_trip_manual_logged}
\end{figure}
\pagebreak

\subsubsection*{[UC14] - Start a Trip in Automatic Mode as a Logged-in user}

When a logged-in user selects a path and chooses to enable \textbf{automatic mode},
the mobile app displays the selected path and attempts to establish a connection with
the required \textbf{external sensors}.
If the connection to the external sensors fails, the mobile app immediately notifies
the user with an error message and the trip does not start. If the connection succeeds,
the app proceeds by activating the \textbf{GPS module}.

Once GPS tracking is active, the GPS module periodically sends position updates,
which the mobile app stores locally and reflects on the map in real time. The trip
identifier is generated and maintained locally during tracking and is sent to the
backend only when the trip is stopped and finalised.
During the trip, if the GPS signal is lost, the tracking loop is interrupted and the
user is notified. If instead the connection to the external sensors drops while the
trip is ongoing, the app stops the automatic mode and displays a corresponding error
message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_automatic.png}
	\caption{Start a Trip in Automatic Mode as a Logged-in User Sequence Diagram}
	\label{fig:use_case_start_trip_automatic_logged}
\end{figure}
\pagebreak

\subsubsection*{[UC15] - Stop a Trip as Guest User}

This use case describes how a guest user stops an ongoing trip.
Since guest trips are not stored on the backend, the entire interaction
is handled locally by the mobile application.

The process starts when the user selects the \textbf{Stop Trip} action.
The mobile app requests the \textbf{GPS module} to deactivate tracking.
Once the GPS module confirms that tracking has been successfully stopped,
the app ends the trip visualisation and updates the user interface accordingly.
No network communication is performed and no data is persisted,
as guest trips are not associated with a backend record.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{Images/Sequence_Diagrams/stop_guest.png}
	\caption{Stop a Trip as a Guest User Sequence Diagram}
	\label{fig:use_case_stop_trip_guest}
\end{figure}
\pagebreak

\subsubsection*{[UC16] - Stop a Trip as a Logged-in User}

A logged-in user wants to stop an ongoing trip.
The interaction begins when the user selects the \textbf{Stop Trip} action
from the mobile app. The app first terminates any active data acquisition,
including GPS tracking and, if the trip was started in automatic mode,
external sensor connections. The collected data and the locally maintained
trip identifier are then validated.
If the validation succeeds, the mobile app sends a finalisation request to
the backend through the \textbf{API Gateway}. The \textbf{TripManager} processes the
request and verifies the trip state. If the trip identifier is invalid or the
trip has already been finalised, an error is returned.

When the trip is valid and the external service is reachable,
the \textbf{TripManager} retrieves a weather
snapshot from the \textbf{WeatherManager} based on the trip time and location.
It then computes the final trip summary, including duration, distance, speed
metrics, sensor data (when available), and weather information.
The summary is stored in the database through the \textbf{QueryManager}.

Upon successful completion, the backend responds with a \textbf{201 Created}
status containing the trip summary. The mobile app displays the final result
to the user. Network failures or server-side errors trigger the corresponding
alternative flows.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/stop_loggedin.png}
	\caption{Stop a Trip as a Logged-in User Sequence Diagram}
	\label{fig:use_case_stop_trip_loggedin}
\end{figure}
\pagebreak

\subsubsection*{[UC17] - Make a Report in Manual Mode}

When a logged-in user wants to manually report an issue encountered on a path,
the user opens the report creation form on  the mobile application.
The app retrieves the current position from the \textbf{GPS module}.
If the position cannot be retrieved, the app immediately displays an error message
and the reporting process is interrupted.

The user fills in the report form by providing report details,
then submits the report. Before contacting the backend, the mobile app performs
a \textbf{local validation} to ensure that all mandatory fields are correctly filled.
If validation fails, the app shows an error message and no request is sent.
When the input is valid, the mobile app sends a \textbf{POST request} containing the
report payload to the backend through the \textbf{API Gateway}. In case of network
timeouts or server-side failures, the app notifies the user accordingly.

The \textbf{API Gateway} forwards the request to the \textbf{ReportManager}, which
creates the report by storing the user identifier, the associated path, the position,
and the report data through the \textbf{QueryManager}. The \textbf{DBMS} generates a
new report identifier and confirms the insertion.
Upon success, the backend returns a \textbf{201 Created} response with the report identifier,
and the mobile app displays a confirmation message to the user.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_manual.png}
	\caption{Make a Report in Manual Mode Sequence Diagram}
	\label{fig:use_case_report_problem_manual}
\end{figure}
\pagebreak

\subsubsection*{[UC18] - Make a Report in Automatic Mode}

During an ongoing trip with automatic mode enabled, external sensors may automatically detect an obstacle or issue
on the path. When such a detection occurs, the mobile app retrieves the current position
from the \textbf{GPS module}. If the GPS position cannot be obtained, the app displays an
error message and the reporting flow terminates.

If the position retrieval succeeds, the app displays a pre-filled report form containing
the detected issue information. The user can review, modify, or complete the report details
before submission.
After confirmation, the mobile app performs a \textbf{local validation} of the generated
report data. If the payload is invalid or incomplete, an error is shown and the backend
is not contacted.

When validation succeeds, the app sends the report payload to the backend via the
\textbf{API Gateway}. Network or server errors result in a timeout and an appropriate
error message is displayed to the user.
The \textbf{ReportManager} receives the request and creates a new report by delegating
its persistence to the \textbf{QueryManager}, which inserts the record into the
\textbf{DBMS}. After successful insertion, the backend responds with a
\textbf{201 Created} status.
Finally, the mobile app informs the user that the report has been submitted successfully.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_automatic.png}
	\caption{Make a Report in Automatic Mode Sequence Diagram}
	\label{fig:use_case_report_problem_automatic}
\end{figure}
\pagebreak

\subsubsection*{[UC19] - Confirm a Report}

While a logged-in user is travelling, the system may notify him of an existing report
located nearby. The mobile app displays a confirmation form, allowing the user to either
confirm, reject, or dismiss the reported issue.
If the user ignores the notification, the form is dismissed after a short period of time
and no further action is taken. If the user submits a decision, the mobile
app performs a \textbf{local validation} to ensure that the input is valid.

When validation succeeds, the app sends the confirmation (or rejection) request to the backend through
the \textbf{API Gateway}. In case of network or server errors, an appropriate error
message is shown to the user.
The \textbf{API Gateway} forwards the request to the \textbf{ReportManager}, which creates
a report entry. The confirmation is persisted through the \textbf{QueryManager} by inserting the record
into the \textbf{DBMS}.

If the operation completes successfully, the backend responds with a
\textbf{201 Created} status and returns the confirmation identifier.
The mobile app then notifies the user that the confirmation has been submitted successfully.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_confirm.png}
	\caption{Confirm a Report Sequence Diagram}
	\label{fig:use_case_confirm_other_reports}
\end{figure}
\pagebreak


\subsubsection*{[UC20] - View Trip History}

When a logged-in user opens the trip history section from the mobile application,
the mobile app sends a request to the backend through the \textbf{API Gateway}
to retrieve the list of trips associated with the user.
The \textbf{API} forwards the request to the \textbf{TripManager}, which
retrieves the user identifier and queries the database through the
\textbf{QueryManager}. The \textbf{DBMS} returns the list of trips linked
to the user account.

If one or more trips are found, the backend responds with a \textbf{200 OK}
status containing the trip list, and the mobile app displays the history
to the user.
If no trips are found, the \textbf{TripManager} returns a
\textbf{404 NOT\_FOUND} response, which is propagated to the mobile app
and shown as a corresponding error message.

In case of network or server failures, the request times out and the
mobile app notifies the user that the service is unavailable.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/trip_history.png}
	\caption{View Trip History and Trip Details Sequence Diagram}
	\label{fig:use_case_view_trip_history}
\end{figure}
\pagebreak

\subsubsection*{[UC21] - Delete a Trip}

A logged-in user wants to permanently delete one of his recorded trips.
He selects a trip to delete from the mobile application. The app sends a \textbf{DELETE}
request to the backend through the \textbf{API Gateway}.

The \textbf{API Gateway} forwards the request to the \textbf{TripManager},
which first verifies that the trip exists and that the requesting user is its owner.
This verification is performed by querying the database through the
\textbf{QueryManager}. If the trip does not exist, the backend answers with a
\textbf{404 NOT\_FOUND} response. If the user is not the owner of the trip,
a \textbf{403 FORBIDDEN} response is generated.

If the ownership check succeeds, the \textbf{TripManager} performs the deletion
by issuing a cascade delete operation through the \textbf{QueryManager},
which removes the trip from the \textbf{DBMS}. Upon successful deletion,
the backend returns a \textbf{204 NO\_CONTENT} response.
The mobile app then confirms the successful removal of the trip to the user.
If a network or server error occurs during the process, the app displays
a corresponding error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/delete_trip.png}
	\caption{Delete a Trip Sequence Diagram}
	\label{fig:use_case_delete_trip}
\end{figure}
\pagebreak

\subsubsection*{[UC22] - View Trip Statistics}

When a logged-in user selects a specific trip from the trip history,
the mobile app sends a request to retrieve detailed statistics for that trip
through the \textbf{API Gateway}.
The \textbf{API} forwards the request to the \textbf{StatsManager}, which
attempts to load precomputed statistics for the selected trip via the
\textbf{QueryManager}. If statistics already exist in the database,
they are retrieved and returned directly.

If no statistics are found, the \textbf{StatsManager} retrieves the raw trip
data from the \textbf{DBMS}, computes the required metrics
(e.g., distance, duration, average speed), stores the newly computed
statistics, and then returns them to the API.

If the trip does not exist or does not belong to the requesting user,
the backend returns a \textbf{404 NOT\_FOUND} response, which is displayed
by the mobile app.
Network or server errors result in a timeout, and the mobile app shows
an appropriate error message to the user.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/stats_trip.png}
	\caption{View Trip Statistics Sequence Diagram}
	\label{fig:use_case_view_trip_statistics}
\end{figure}
\pagebreak

\subsubsection*{[UC23] - View Overall Statistics}

A logged-in user opens the overall statistics section from the mobile app.
The application sends a request to the backend through the \textbf{API Gateway}
to retrieve aggregated statistics across all user trips.

The \textbf{API} delegates the request to the \textbf{StatsManager}, which
first checks whether previously computed overall statistics are still valid
by comparing the stored trip count with the current number of trips retrieved
through the \textbf{QueryManager}.

If valid statistics already exist, they are loaded from the database and
returned to the mobile app with a \textbf{200 OK} response.
If the stored data is missing or outdated, the \textbf{StatsManager} retrieves
all trip records from the \textbf{DBMS}, computes the aggregated metrics
(e.g., total distance, total duration, average speed), stores the updated
statistics, and returns the results to the client.

If no trips exist for the user, the backend responds with a
\textbf{404 NOT\_FOUND} status, which is propagated to the mobile app.
Any network or server-side failure results in a timeout and an error message
displayed on the client.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/stats_overall.png}
	\caption{View Overall Statistics Sequence Diagram}
	\label{fig:use_case_view_overall_statistics}
\end{figure}
\pagebreak

% --------------------------------------------------------------------------
% Component Interfaces
% --------------------------------------------------------------------------

\section{Component Interfaces}
\label{sec:component_interfaces}

This section describes the operations exposed by each backend component and the
interfaces through which these components collaborate at runtime.

Unless explicitly noted, all Manager methods operate in an authenticated context:
the identifier of the currently logged-in user is implicitly supplied by the
\textbf{API Gateway} after validating the access token, and is therefore not
included in the method signatures.
The \textbf{QueryManager}, in contrast, interacts directly with the relational DBMS
and does not rely on authentication parameters.

\subsection*{User Module - AuthManager}
The \textbf{AuthManager} handles user authentication, credential verification,
token generation, and logout flows.
It is invoked through the \textbf{API Gateway} and relies on the \textbf{QueryManager}
to retrieve and persist authentication metadata, including refresh tokens stored in the DBMS.

It exposes the following operations:

\begin{itemize}
	\item \textbf{registerUser(email, password, profileData)}: validates registration data, checks whether the email is
	      already in use, hashes the password, stores the user profile, persists a refresh token, and returns a newly issued access/refresh token pair.
	\item \textbf{loginUser(email, password)}: verifies the supplied credentials and, if valid, issues fresh access and refresh
	      tokens and persists the new refresh token.
	\item \textbf{logout(refreshToken)}: invalidates the provided refresh token and terminates the associated session in the DBMS.
	      % \item \textbf{verifyPassword(userId, candidatePassword)}: internal method used to compares the given password against the 
	      % stored hash to authorise profile updates requiring re-authentication.
	      % \item \textbf{generateToken(userId)}: internal method that produces a short-lived access token and a long-lived refresh
	      %  token for the authenticated user.
\end{itemize}

\subsection*{User Module - UserManager}
The \textbf{UserManager} manages user-profile data and receives requests via the
\textbf{API Gateway}.
It uses the \textbf{QueryManager} for persistence and exposes:

\begin{itemize}
	\item \textbf{updateProfile(userId, profilePayload)}: validates editable fields, prevents duplicate emails, applies the update to the stored profile, and returns the updated information.
\end{itemize}

\subsection*{PathManager}

The \textbf{PathManager} implements all functionality related to bike paths:
manual and automatic creation, route computation, ranking of candidate routes,
path selection, deletion, and visibility updates.
It is accessed through the \textbf{API Gateway} and uses the \textbf{QueryManager}
to retrieve and update persistent path data.

The public operations are:

\begin{itemize}
	\item \textbf{findPath(start, end, constraints)}: retrieves the required portion of the graph, including report-derived condition indicators
	      for each segment, and computes candidate routes satisfying the given constraints.
	      % \item \textbf{computeBestPath(paths)}: internal method that selects and ranks the best route among the candidates returned by \textbf{findPath}.
	\item \textbf{getPathDetails(pathId)}: returns metadata, geometry, condition indicators, and aggregated reports for the selected path and its segments.
	\item \textbf{createPath(pathPayload, userId)}: validates metadata and segment lists (manual mode) or GPS-derived samples (automatic mode), persists
	      the new path, and associates it with the creator.
	\item \textbf{getPathsByUser(userId)}: retrieves all paths created by the authenticated user.
	\item \textbf{deletePath(pathId, userId)}: verifies ownership and removes the specified path, triggering cascade deletion of dependent records.
	\item \textbf{updateVisibility(pathId, visibility, userId)}: enforces ownership and updates the stored visibility field.
\end{itemize}

\subsection*{TripManager}

The \textbf{TripManager} coordinates the lifecycle of a cycling session.
It receives GPS samples from the mobile app, stores trip metadata, and, upon trip
completion, composes the final summary enriched with weather data retrieved as a snapshot
from the \textbf{WeatherManager}. All persistent data is saved through the \textbf{QueryManager}.

The component exposes the following methods:

\begin{itemize}
	\item \textbf{finalizeTrip(tripPayload, userId)}: receives the final trip payload from the API (including the locally
	      generated trip identifier), obtains a weather snapshot from the \textbf{WeatherManager}, composes the completed trip summary and stores it.
	\item \textbf{getTripsByUser(userId)}: returns the complete list of trips owned by the authenticated user, ordered by time.
	\item \textbf{deleteTrip(tripId, userId)}: deletes the specified trip after verifying ownership.

\end{itemize}

\subsection*{ReportManager}

The \textbf{ReportManager} handles submission and confirmation of obstacle reports,
both manual and automatic.
It centralises validation, association to a path, and persistence.
It also updates path-segment condition indicators in the DBMS that are consumed by the \textbf{PathManager} when computing rankings, without requiring additional calls to the ReportManager at query time.

\begin{itemize}
	\item \textbf{createReport(position, payload)}: processes manual reports, automatic sensor-based reports, and confirmations of existing reports.
	      It validates payload and location data, inserts the report, and returns the newly created report identifier.
\end{itemize}

\subsection*{StatsManager}

The \textbf{StatsManager} computes aggregated statistics over user trips and
derives detailed metrics for individual trips.
Raw and processed data are retrieved via the \textbf{QueryManager}.

\begin{itemize}
	\item \textbf{computeOverallStats(userId)}: computes the user-level aggregated statistics (e.g., total distance, total duration, average speed), using cached values when available and recomputing them when the stored trip count differs from the current one.
	\item \textbf{computeTripStats(userId, tripId)}: computes the detailed statistics for a specific trip, returning previously stored values when available or deriving them from the trip summary data and then persisting the result for subsequent requests.
\end{itemize}

\subsection*{WeatherManager}

The \textbf{WeatherManager} interfaces with an external weather provider and is used to
enrich trip summaries with environmental context.

\begin{itemize}
	\item \textbf{getWeather(location, timeWindow)}: queries the external weather API and returns a snapshot containing
	      temperature, precipitation, and wind information for the specified interval.
\end{itemize}

\subsection*{QueryManager}

The \textbf{QueryManager} is the uniform access point to the DBMS.
It encapsulates all SQL operations required by the Managers, ensuring consistency and
separation between domain logic and data storage.

It exposes:

\begin{itemize}
	\item \textbf{checkDuplicateEmail(email)}: verifies whether an email is already associated with an existing user.
	\item \textbf{insertUser(hashedData)}: inserts a new user record with hashed credentials and stores a refresh token issued for the user.
	\item \textbf{checkEmail(email)}: retrieves credential metadata for login attempts.
	\item \textbf{deleteRefreshToken(refreshToken)}: removes the refresh token associated with the terminated session.
	\item \textbf{updateUser(userId, profilePayload)}: stores changes to user profile fields.
	\item \textbf{fetchPaths(areaBounds)}: retrieves the relevant segments for route computation, including condition indicators already updated from reports.
	\item \textbf{fetchPathById(pathId)}: returns the full record of the specified path, including aggregated report data for its segments.
	\item \textbf{insertPath(pathPayload, userId)}: stores new path metadata and geometry.
	\item \textbf{fetchUserPaths(userId)}: retrieves all paths created by the given user.
	\item \textbf{fetchReportsByPath(pathId)}: retrieves reports associated with the path segments to support condition scoring.
	\item \textbf{verifyPathOwnership(pathId, userId)}: checks whether the specified path belongs to the requesting user.
	\item \textbf{deletePathCascade(pathId)}: deletes a path and its dependent records.
	\item \textbf{updateVisibility(pathId, visibility)}: updates the visibility field of the selected path.
	\item \textbf{insertTripSummary(tripSummary, userId)}: inserts a completed trip summary with its associated weather snapshot, if present.
	\item \textbf{fetchUserTrips(userId)}: retrieves all trips belonging to the user, ordered by date.
	\item \textbf{deleteTripCascade(tripId)}: removes the specified trip and all related records.
	\item \textbf{verifyTripOwnership(tripId, userId)}: checks whether the specified trip belongs to the requesting user.
	\item \textbf{insertReport(position, payload)}: persists manual or automatic reports and confirmations.
	\item \textbf{fetchTripStats(tripId, userId)}: retrieves the precomputed statistics associated with the given trip and user, if already stored.
	\item \textbf{saveTripStats(stats, tripId, userId)}: persists the computed per-trip statistics for the given trip and user.
	\item \textbf{fetchTripCount(userId)}: returns the number of completed trips associated with the given user, used to validate whether cached overall statistics are still up to date.
	\item \textbf{fetchStats(userId)}: retrieves the cached overall statistics previously stored for the given user, if available.
	\item \textbf{saveStats(stats, userId)}: stores or updates the overall statistics for the given user, together with the current trip count used as a validity reference.
\end{itemize}

% --------------------------------------------------------------------------
% Architectural Styles and Patterns
% --------------------------------------------------------------------------

\section{Selected Architectural Styles and Patterns}
\label{sec:arch_patterns}%

The BBP system adopts a \textbf{three-tier, layered architecture} composed of a thin mobile client,
an application tier implementing all business rules, and a relational data tier.
This structure ensures clear responsibility separation, simplifies maintenance,
and supports the mobile-first design goals described in the system overview.

\begin{itemize}
	\item \textbf{API Gateway with modular backend}.
	      All external requests pass through a Gateway that centralises routing, authentication,
	      input validation and error normalisation.
	      Behind it, the backend is organised as a collection of Managers, each encapsulating
	      a coherent vertical slice of functionality (paths, reports, trips, users).
	      This separation reduces coupling, facilitates parallel development, and keeps
	      inter-component interactions lightweight.

	\item \textbf{RESTful, stateless communication}.
	      The mobile app interacts with the backend exclusively through resource-based HTTPS
	      endpoints.
	      The application tier remains stateless for access tokens: session information is kept client-side through
	      short-lived access tokens stored in secure storage, making the system horizontally scalable
	      and resilient to server restarts. Refresh tokens are persisted in the DBMS to support logout and rotation,
	      introducing minimal server-side state explicitly managed by the \textbf{AuthManager}.

	\item \textbf{Service Layer pattern}.
	      Each Manager acts as a well-defined service boundary that hides internal logic,
	      aggregates operations into meaningful methods, and exposes a stable API to the Gateway.
	      This pattern avoids exposing domain details to the controller layer and fosters
	      maintainability and testability.

	\item \textbf{DAO pattern}.
	      The \textbf{QueryManager} centralises access to the relational DBMS and hides SQL concerns
	      from the rest of the backend.
	      By enforcing consistency checks and persistence rules in a single component, the system
	      becomes less error-prone and more adaptable to future schema evolution or database
	      optimisation.

	\item \textbf{Security patterns}.
	      Authentication is based on JWT-like tokens validated by the Gateway and the AuthManager.
	      Boundary validation prevents malformed inputs and mitigates injection risks.
	      Since authorisation depends solely on token claims, backend nodes remain stateless and
	      interchangeable, matching the scalability goals of the architecture.
\end{itemize}

% --------------------------------------------------------------------------
% Other Design Decisions
% --------------------------------------------------------------------------

\section{Other Design Decisions}
\label{sec:other_design_decisions}%

Beyond the architectural style, the following design choices strengthen the BBP system's
quality attributes and align with the mobile-first scope:

\begin{itemize}
	\item \textbf{Authentication and authorisation}.
	      Access control relies on short-lived access tokens and refresh tokens securely stored
	      on the mobile client. Refresh tokens are also persisted in the DBMS to enable validation,
	      rotation, and logout.
	      The API Gateway enforces authentication, while domain-level authorisation (guest vs
	      authenticated user) is performed inside the Managers.

	\item \textbf{Validation and error handling}.
	      Validation occurs at the system boundary (API Gateway) ensuring malformed
	      (e.g. missing JWT, invalid JSON schema) or invalid endpoint requests
	      are filtered before reaching the business layer.
	      On the other hand, user input is validated when the request reaches the
	      business layer, ensuring that incomplete or incorrect data will not be saved, and
	      the user will be correctly notified.
	      Errors are normalised into structured HTTP responses so the mobile client can present
	      consistent messages. Domain-specific errors (e.g., \texttt{NOT\_FOUND}) are explicitly
	      mapped and surfaced through the Gateway.
	      Empty collections are treated as \texttt{NOT\_FOUND} conditions to explicitly signal the absence
	      of domain entities rather than returning empty datasets.

	\item \textbf{Fault tolerance}.
	      Calls to external services (e.g., weather provider) are wrapped with timeouts,
	      fallbacks and default values.
	      Even in case of partial failure, critical user actions (such as trip completion) are
	      preserved and stored.

	\item \textbf{Data integrity}.
	      The \textbf{QueryManager} encapsulates transactional boundaries to guarantee atomic
	      updates during operations such as path creation, trip summary storage and report
	      confirmation, isolating Managers from SQL concerns.

\end{itemize}
