% --------------------------------------------------------------------------
% Architectural Design
% --------------------------------------------------------------------------

\section{Architectural Overview: High-level components and their interactions}
\label{sec:overview}%

The architecture of the Best Bike Paths (BBP) system follows a classic
\textbf{three-tier structure}, separating the software into a presentation layer,
an application layer, and a data layer. This architectural style ensures a clear
division of responsibilities and simplifies the evolution of the system over time.
Since BBP is conceived as a mobile-centric platform, the presentation tier is
implemented entirely through the BBP mobile app, which communicates with
the backend via RESTful APIs over HTTPS.

\subsection*{Presentation Layer}

The presentation layer consists solely of the \textbf{BBP mobile app},
which serves as the primary interface between users and the system.
This layer is responsible for:
\begin{itemize}
	\item rendering the user interface and handling user interactions;
	\item acquiring device-level data (GPS, accelerometer, gyroscope) during trips;
	\item displaying bike paths, trip summaries, statistics, and reports;
	\item invoking backend functionalities through HTTPS requests.
\end{itemize}

The mobile app is intentionally designed as a \textbf{thin client}.
All domain logic, decision processes, ranking operations, and aggregation of path
information are delegated to the application layer.
The app interacts with device-level subsystems such as the GPS module
and external sensors (when available), elements that are not part of the backend architecture.
The mobile app also uses the secure storage facilities provided by the operating system
(iOS Keychain / Android Keystore) to safely store authentication tokens and other sensitive data.

\subsection*{Application Layer}

The application layer embodies the \textbf{core business logic} of BBP.
It is implemented as a modular backend composed of independent yet cooperating \textbf{components},
each encapsulating a well-defined responsibility.
These components are logically independent in terms of responsibilities and interfaces,
but they are part of a single backend app.
The main functional components include:

\begin{itemize}
	\item \textbf{User Module}: contains the \textbf{AuthManager} and the
	      \textbf{UserManager}, responsible for authentication, credential verification,
	      and management of user profiles.
	\item \textbf{TripManager}: handles
	      the lifecycle of a cycling trip and produces trip summaries enriched with
	      contextual weather data, trip statistics, and reports encountered during the trip.
	\item \textbf{PathManager}:  responsible for creating paths, computing routes,
	      ranking candidate paths according to their condition and effectiveness, and managing
		  visibility and deletion.
	\item \textbf{ReportManager}: responsible
	      for storing and aggregating reports, retrieving reports by path, managing confirmations,
	      and updating path-condition indicators.
	\item \textbf{StatsManager}: computes and stores user statistics and per-trip metrics, including overall aggregations.
	\item \textbf{QueryManager}: centralises database access and exposes CRUD-style
	      operations to all Managers, enforcing a uniform data-access interface.
\end{itemize}

The application layer also relies on supporting services that encapsulate third-party integrations:
\begin{itemize}
	\item \textbf{WeatherService}: adapter for the external weather provider used 
	to fetch and aggregate meteorological data for trip summaries and history retrieval.
	\item \textbf{GeocodingService}: integrates with an external geocoding provider
	      to resolve user-provided origins and destinations into coordinates for path search.
	\item \textbf{SnappingService}: maps raw segments to road geometry to improve
	      path accuracy during manual path creation before storage and analysis.
\end{itemize}

All modules are accessed through the \textbf{API Entrypoint}, which exposes a set of
RESTful sub-APIs and routes incoming requests to the appropriate Manager.

\subsection*{Data Layer}

The data layer consists of a \textbf{relational DBMS} storing all persistent
information relevant to the system's domain, including:
\begin{itemize}
	\item user profiles and authentication credentials;
	\item trip records and associated GPS data;
	\item bike path segments and their aggregated conditions;
	\item reports, confirmations, and metadata about obstacles;
	\item computed statistics and weather snapshot.
\end{itemize}

All interactions with the DBMS are mediated by a single \textbf{QueryManager},
which centralises data-access operations and offers a uniform interface for
executing queries. This design keeps persistence concerns separated from the
application logic and reduces duplication across components.

% --------------------------------------------------------------------------
% Component View
% --------------------------------------------------------------------------

\section{Component View}
\label{sec:component_view}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Architectural_Overview/component_view.png}
	\caption{Component View Diagram}
	\label{fig:component_view}
\end{figure}

This section describes the main software components that constitute the BBP backend
and their responsibilities. As required by the three-tier architecture adopted by the system,
the backend is structured into a set of independent yet cooperating modules, each exposing
well-defined interfaces and encapsulating a cohesive subset of the app logic.

\subsubsection{API Entrypoint}
The \textbf{API Entrypoint} represents the single entry point for all interactions between the BBP mobile
app and the backend. It is a logical layer implemented inside the backend application. It centralizes request routing
toward the Managers, applies authentication middleware on
protected endpoints, performs input validation at the boundary, and translates domain errors into
HTTP responses.

The API Entrypoint exposes the following logical sub-APIs:
\begin{itemize}
	\item \textbf{AuthAPI}: endpoints for login, logout, and token refresh.
	\item \textbf{UserAPI}: endpoints for registration and profile retrieval.
	\item \textbf{TripAPI}: endpoints for creating, listing, and deleting trips.
	\item \textbf{PathAPI}: endpoints for route computation and retrieval of path metadata.
	\item \textbf{ReportAPI}: endpoints for submitting and retrieving obstacle reports.
	\item \textbf{StatsAPI}: endpoints for retrieving user statistics and trip metrics.
\end{itemize}

\subsubsection{User Module}
The \textbf{User Module} groups two Managers that collectively handle all user-related
flows exposed by the backend, including registration, login, logout, token refresh,
and profile management. It centralises credential checks, uniqueness constraints,
and the enforcement of authentication rules at the application layer.

\begin{itemize}
	\item \textbf{AuthManager}, responsible for credential verification, access/refresh token
	      issuance and rotation, and session invalidation (logout). Refresh tokens are
	      persisted and revoked through the \textbf{QueryManager}.
	\item \textbf{UserManager}, responsible for user registration and profile updates,
	      including validation of editable fields and prevention of duplicate email/username.
\end{itemize}

Both Managers use the \textbf{QueryManager} for data retrieval and persistence, while the
\textbf{API Entrypoint} applies authentication middleware to protect profile endpoints.

\subsubsection{TripManager}
The \textbf{TripManager} coordinates the lifecycle of a cycling session.
GPS samples and live tracking stay on the mobile app during the trip; the backend is contacted only at stop time.
Upon trip completion, the app sends the final payload containing origin/destination, timestamps, and trip segments.
The TripManager persists the trip data through the \textbf{QueryManager} and enriches the stored record with environmental
data retrieved through the \textbf{WeatherService} and metrics computed by the \textbf{StatsManager}. When a user retrieves
their trip history, the TripManager also triggers on-demand enrichment: it requests missing weather data, statistics,
and associated reports through the \textbf{ReportManager}, then persists any newly computed values.

\subsubsection{PathManager}
The \textbf{PathManager} is responsible for retrieving graph
data from the database, computing optimal routes between two locations,
and ranking alternative routes according to their quality and reported conditions.
For path search requests, it resolves textual origins and destinations through the
\textbf{GeocodingService} before querying the database.
It also manages path creation in both manual and automatic modes, updates visibility,
and handles deletion requests. When the client draws a manual path, the PathManager
invokes the \textbf{SnappingService} to align coordinates to the road network.
It also is responsible for creating new paths, either from user-drawn segments
or from GPS samples recorded during automatic path creation. For both modes, 
it interacts with the \textbf{SnappingService} to snap drawn paths to
the road network.
This service exposes the routing logic to the API Entrypoint and interacts with the
\textbf{QueryManager} to retrieve pre-aggregated segment conditions alongside path 
data needed for route computation.

\subsubsection{ReportManager}
The \textbf{ReportManager} handles obstacle reports submitted
by users or automatically detected during trips. It stores and aggregates reports, manages
confirmation and rejection flows, updates path-quality indicators, and exposes relevant data to the mobile app.
This component interacts with the \textbf{QueryManager} for persistence and with the
\textbf{PathManager} when updated conditions affect route evaluation.
The \textbf{TripManager} may also invoke the ReportManager during trip history retrieval
to enrich trip summaries with associated reports.

\subsubsection{StatsManager}
The \textbf{StatsManager} optimizes system performance by using a state-aware recomputation strategy that minimizes redundant processing.
For overall statistics, it compares the user's current total trip count against the value stored from the last calculation; it only triggers a full
aggregation of data if the \textbf{QueryManager} reports a change in the trip count, otherwise it simply retrieves the previously stored results.

For individual trip statistics, the manager utilizes a lazy initialization pattern by asking the \textbf{QueryManager} if a processed record already
exists for a specific trip ID. If the statistics are found, they are returned immediately; if not, the manager computes and persists them for the first time.
This dual-layered approach ensures that data is only processed when necessary, effectively eliminating double computations by relying on the \textbf{QueryManager}
to track the state of processed data.
The \textbf{TripManager} calls the StatsManager at trip finalization and also on demand when trip history retrieval detects missing statistics.

\subsubsection{QueryManager}
The \textbf{QueryManager} is the data-access component of the backend.
It acts as the single entry point for interacting with the relational DBMS and
provides a set of methods to retrieve, insert, update, and delete domain data.
Centralising data access in one component simplifies consistency checks, reduces duplicated logic, and
keeps the domain layer independent of database details.

\subsubsection{WeatherService}
The \textbf{WeatherService} wraps calls to an external provider and aggregates
meteorological data by sampling coordinates along a trip route, including path segment polylines
and origin/destination when available. The resulting snapshot is returned to the \textbf{TripManager},
which stores it through the \textbf{QueryManager}.
The TripManager also reuses the WeatherService during trip history retrieval when stored data is missing.

\subsubsection{GeocodingService}
The \textbf{GeocodingService} wraps calls to an external provider to
translate location strings into coordinates. It returns resolved coordinates to the
\textbf{PathManager} and isolates third-party integration concerns.

\subsubsection{SnappingService}
The \textbf{SnappingService} interfaces with an internal routing engine to
snap user-drawn paths to the road network, ensuring accurate route representation.
It returns the adjusted path to the \textbf{PathManager}.

% --------------------------------------------------------------------------
% Deployment View
% --------------------------------------------------------------------------

\section{Deployment View}
\label{sec:deployment_view}%

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{../Images/deployment_view/deployment_view.png}
	\caption{Deployment View of the BBP System}
	\label{fig:deployment_view}
\end{figure}

The deployment view describes the hardware and software infrastructure supporting the \textit{BBP} system. Each tier is
deployed on logically separated infrastructure components and communicates with the others using secure protocols.

\begin{itemize}
	\item \textbf{Presentation Tier:}
	      this tier includes all devices through which end users interact with the BBP system.
	      The primary clients are smartphones or tablets running iOS or Android, where the BBP mobile application is installed.
	      These devices communicate with the backend exclusively via HTTPS, ensuring confidentiality and data integrity.
	      While the client executes local presentation logic, no security-critical or authoritative business logic is enforced at this level.
	      The devices capture user input and location, display results, and forward authenticated or unauthenticated HTTPS requests
	      toward the Application Tier.

	\item \textbf{Application Tier:}
	      this tier is responsible for handling incoming traffic, enforcing security, and executing the core business logic of the system.
	      External requests first pass through the \textit{Cloudflare Edge} and then reach a shared \textit{NGINX} reverse proxy
	      running on the same VPS as the application containers. NGINX is the only component exposing ports \textbf{80/443},
	      terminates TLS using Cloudflare Origin Certificates, applies basic filtering and rate limiting, and forwards traffic
	      to the backend containers over a private Docker network using HTTP.
	      The backend application itself runs in one or more stateless Docker containers (replicas), allowing horizontal scaling.
	      The snapping engine runs as a separate internal container and is reachable only over the private Docker network.
	      Since authentication tokens are included in each request header, no server-side session state is maintained, enabling horizontal
	      scaling and dynamic replica management.

	\item \textbf{Data Tier:}
	      the Data Tier consists of a managed PostgreSQL database.
	      This database stores all persistent system data such as user information, paths, trips, and analytics.
	      Backend servers connect to the managed service over the network.
	      Centralizing the database simplifies backup strategies, consistency enforcement, and maintenance operations, while still
	      allowing for potential future extensions such as replication or clustering without altering the upper tiers of the system.

\end{itemize}

% --------------------------------------------------------------------------
% Runtime View
% --------------------------------------------------------------------------

\section{Runtime View}
\label{sec:runtime_view}%

The Runtime View describes how the components of the BBP system collaborate
to realise the behaviour specified in the functional requirements.
While the Component View focuses on the static organisation of the backend,
the Runtime View illustrates how these components interact dynamically
during the execution of the main use cases.

All diagrams follow the modular structure of the backend.
The mobile client invokes the \textbf{API Entrypoint}, which routes each request to the
appropriate \textbf{Manager}. Persistence operations are centralised in the \textbf{QueryManager}.
When required, Managers also interact with dedicated \textbf{Services}
to complete the requested operation.

The sequence diagrams that follow cover the core use cases and show how responsibilities
are distributed at runtime.

\subsubsection*{[UC1] - User Registration}

A new user wants to register into the BBP system.
The process begins on the mobile app, where the guest user opens the registration page,
and fills in the required details: username, email, and password.
A first \textbf{local validation} step checks for malformed inputs before contacting the \textbf{backend}.

If the data is valid, the mobile app sends a registration request to the \textbf{API Entrypoint}, which forwards it to the \textbf{UserManager}.
The \textbf{UserManager} checks whether the email and username are already in use by querying the DBMS through the \textbf{QueryManager}.
If the email or username already exists, the system returns an error and the mobile app notifies the user.

When both are unique, the \textbf{UserManager} stores the new user in the database.
The flow ends successfully with a new user created.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_registration.png}
	\caption{User Registration Sequence Diagram}
	\label{fig:use_case_user_registration}
\end{figure}
\pagebreak

\subsubsection*{[UC2] - User Log In}

A guest user wants to authenticate and obtain access to the system. The process starts
when the user opens the login form and submits credentials through the mobile app. After
a \textbf{local validation}, the app sends an HTTP request to the login endpoint exposed by the \textbf{API Entrypoint}.

The \textbf{API Entrypoint} forwards the request to the \textbf{AuthManager}, which first checks whether the provided
email exists by querying the \textbf{DBMS} through the \textbf{QueryManager}. If the email is not found,
the backend returns a \textbf{404} error, which the mobile app displays to the user.
If the user exists, the \textbf{AuthManager} verifies the submitted password. Invalid credentials
lead to a \textbf{401} response and the corresponding error message on the client.

When the credentials are correct, the \textbf{AuthManager} generates an \textbf{access token} and a \textbf{refresh token},
stores the refresh token in the \textbf{DBMS}, and returns both tokens together with the user information to the mobile app.
The app stores the tokens securely using the device's \textbf{secure storage} facility.
The user is then successfully logged in and the app proceeds to show the appropriate authenticated UI.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_login.png}
	\caption{User Log In Sequence Diagram}
	\label{fig:use_case_user_login}
\end{figure}
\pagebreak

\subsubsection*{[UC3] - User Log Out}

When a logged-in user initiates the logout operation from the mobile app, the client first removes the locally
stored tokens from the device's \textbf{secure storage}. This ensures the user is logged out on the client side
even if the network request fails.

After clearing local data, the mobile app sends an HTTP request to the logout endpoint exposed by the \textbf{API Entrypoint}.
The \textbf{API Entrypoint} forwards the request to the \textbf{AuthManager}, which invalidates the current session by deleting
the corresponding \textbf{refresh token} through the \textbf{QueryManager}. The \textbf{QueryManager} executes a
\textbf{DELETE} operation on the database to remove the stored token.

If the operation succeeds, the server returns a \textbf{204 NO\_CONTENT} response. If a network or server error occurs
(timeout or \textbf{5xx}), the local logout remains effective and the server revocation can be retried later.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/user_logout.png}
	\caption{User Log Out Sequence Diagram}
	\label{fig:use_case_user_logout}
\end{figure}
\pagebreak

\subsubsection*{[UC4] - Edit Personal Profile}

A logged-in user wants to edit his personal profile. 
After the logged-in user submits the edited data, the mobile app
locally validates it. If the data is incomplete or invalid,
the app immediately notifies the user. If the input is valid, the updated payload
is sent with a \textbf{PATCH} request to the \textbf{API Entrypoint},
which delegates the request to the \textbf{UserManager}. The diagram illustrates
the email update flow, but the same sequence applies to username changes as well.
Before applying the update, the \textbf{UserManager} checks for duplicates
to prevent conflicts.

The update is forwarded to the \textbf{QueryManager}, which issues the corresponding \textbf{UPDATE} operation on the database.
If the update succeeds, the backend returns a confirmation message.

In case of network or server errors during the request, the mobile app shows an appropriate error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/edit_profile.png}
	\caption{Edit Personal Profile Sequence Diagram}
	\label{fig:use_case_edit_profile}
\end{figure}
\pagebreak

\subsubsection*{[UC5] - Search for a Path}

A user searches for bike paths between two locations by providing a starting point and a destination
through the mobile app. Before contacting the backend, the app performs a \textbf{local validation}
to ensure that both fields are not empty. 

When the input is valid, the mobile app sends a search request to the backend through the
\textbf{API Entrypoint}. The API Entrypoint forwards the request to the \textbf{PathManager}, which is
responsible for path computation.
The \textbf{PathManager} first resolves the origin and destination through the
\textbf{GeocodingService} to obtain coordinates. It then retrieves the relevant
path segments and related information from the database by interacting with the
\textbf{QueryManager}. Once the data is available, it computes
the best path or set of paths according to the system criteria and user constraints.

If one or more valid routes are found, the \textbf{PathManager} returns the results to the
\textbf{API Entrypoint}, which responds to the mobile app with a \textbf{200 OK} message containing
the suggested paths. The app then displays the available routes to the user.
If no suitable route can be computed, the \textbf{PathManager} returns an empty list,
with a  \textbf{200 OK} response.

In the event of network failures or server-side errors, the interaction is interrupted and
the mobile app shows a generic "Network unavailable" error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/search_path.png}
	\caption{Search for a Path Sequence Diagram}
	\label{fig:use_case_search_path}
\end{figure}
\pagebreak

\subsubsection*{[UC6] - Select a Path}

After receiving a list of suggested routes, the user can select a specific path to
see its details on a map, and inspect its associated reports. When the user selects a path,
the mobile app sends a request containing the selected path identifier to the backend
through the \textbf{API Entrypoint}.

Path details (e.g., segments and status) are obtained during the search phase,
while reports are refreshed every time a path is selected to ensure the information
is always up to date.

The \textbf{API Entrypoint} forwards the request to the \textbf{ReportManager}, which retrieves
the corresponding reports by querying the database through the \textbf{QueryManager}.

If reports are found, the ReportManager returns them to the API Entrypoint,
which responds with a \textbf{200 OK} status and forwards the information to the mobile app.
The app then displays the list of reports to the user.

If no report is available for the selected path, the backend returns an empty list
with a \textbf{200 OK} response. Network or server failures are handled consistently
with other interactions.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\textwidth]{Images/Sequence_Diagrams/select_path.png}
	\caption{Select a Path Sequence Diagram}
	\label{fig:use_case_select_path}
\end{figure}
\pagebreak

\subsubsection*{[UC7] - Create a Path in Manual Mode}

When a logged-in user decides to create a new path, the interaction starts by opening
the path creation page in the mobile app. The user is first asked to provide the required
metadata and to select the \textbf{manual creation mode}. Once the metadata is submitted,
the mobile app performs an initial \textbf{local validation}.

If the metadata is invalid or incomplete, the app immediately notifies the user.
Otherwise, the app displays an interactive map that allows the user to manually draw
the path by defining its segments. As segments are drawn, the app can call the backend
snapping endpoint (\textbf{POST /paths/snap}) to align the coordinates to the road network
via the \textbf{SnappingService}.
Any error during the snapping process is non-blocking, so the flow continues and the
user is not interrupted if snapping fails at any moment.
After the drawing phase, the user submits the generated segments.
Then, the mobile app sends a \textbf{POST} request to the backend through the \textbf{API Entrypoint}.
The entrypoint forwards the request to the \textbf{PathManager}, which handles the creation logic.

The PathManager delegates the persistence of the new path to the \textbf{QueryManager},
which executes the corresponding \textbf{INSERT} operation on the \textbf{DBMS}, associating
the path with the authenticated user.
Upon successful insertion, the PathManager returns the generated path identifier to the
API Entrypoint, which responds with a \textbf{201 Created} status. The mobile app receives
the response and displays a confirmation message indicating that the path has been
successfully created. In case of network or server errors, the app notifies the user
accordingly.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/create_manual.png}
	\caption{Create a Path in Manual Mode Sequence Diagram}
	\label{fig:use_case_create_path_manual}
\end{figure}
\pagebreak

\subsubsection*{[UC8] - Create a Path in Automatic Mode}

When a logged-in user chooses to create a new path in \textbf{automatic mode}, the
mobile app first displays a form to collect the required metadata and performs a
preliminary \textbf{local validation}. If the validation fails, the user is immediately
notified.

If the input is valid, the \textbf{GPS module} continuously provides
location samples while the user is moving.
The mobile app locally stores these samples throughout the tracking session.

If a GPS signal error occurs during movement, the app detects the issue, interrupts
the process, and informs the user. When the user completes the recording session,
the collected samples undergo a final \textbf{local validation}. If the data is invalid, 
the user is notified.

If both metadata and recorded samples are valid, the mobile app sends a \textbf{POST}
request to the backend through the \textbf{API Entrypoint}. The entripoint forwards the request
to the \textbf{PathManager}, which stores the new path by delegating persistence to the
\textbf{QueryManager}.
After the path is successfully inserted into the \textbf{DBMS}, the PathManager returns
the generated path identifier to the API Entrypoint, which responds with a
\textbf{201 Created} status. The mobile app then displays a success message confirming
that the automatically generated path has been saved.

Network or server failures are handled consistently with other interactions.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/create_automatic.png}
	\caption{Create a Path in Automatic Mode Sequence Diagram}
	\label{fig:use_case_create_path_automatic}
\end{figure}
\pagebreak

\subsubsection*{[UC9] - View Path Library}

A logged-in user wants to view the list of paths previously created.
The interaction starts when the user opens the personal path library section
in the mobile application. The app sends a request to the backend through the
\textbf{API Entrypoint} to retrieve all paths associated with the authenticated user.
The \textbf{API Entrypoint} forwards the request to the \textbf{PathManager},
which retrieves the list of paths owned by the user by querying the database
through the \textbf{QueryManager}. The QueryManager executes the corresponding
\textbf{SELECT} operation on the \textbf{DBMS}.

If one or more paths are found, the list is returned to the mobile app and
displayed to the user. If no paths exist for the given user, the backend returns
a \textbf{200 OK} response with an empty list, and the mobile app notifies the user
that no paths are available.

In case of network or server errors, the request is interrupted and the
mobile app displays an appropriate error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/path_library.png}
	\caption{View Path Library Sequence Diagram}
	\label{fig:use_case_view_path_library}
\end{figure}
\pagebreak

\subsubsection*{[UC10] - Manage Path Visibility}

A logged-in user wants to change the visibility of one of his previously created paths.
The interaction begins when the user selects a path and requests a visibility update
from the mobile application. The app sends a \textbf{PATCH} request to the backend
through the \textbf{API Entrypoint}, specifying the desired visibility value.

The \textbf{API Entrypoint} forwards the request to the \textbf{PathManager},
which first verifies that the requesting user is the owner of the selected path.
This ownership check is performed by querying the database through the
\textbf{QueryManager}. If the path does not exist, the backend returns a
\textbf{404 NOT\_FOUND} response. If the user is not the owner, a
\textbf{403 FORBIDDEN} response is generated.

If the ownership verification succeeds, the \textbf{PathManager} updates the
visibility attribute of the path by issuing an \textbf{UPDATE} operation
through the \textbf{QueryManager}. Upon successful completion, the backend
returns a \textbf{200 OK} response, and the mobile app confirms the update to the user.
Network or server-side errors result in the interruption of the flow and the
display of an appropriate error message on the client.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/manage_visibility.png}
	\caption{Manage Path Visibility Sequence Diagram}
	\label{fig:use_case_manage_visibility}
\end{figure}
\pagebreak

\subsubsection*{[UC11] - Delete a Path}

When a logged-in user wants to permanently delete one of his paths,
he first selects a path to delete from the mobile
application. The app sends a \textbf{DELETE} request to the backend through the
\textbf{API Entrypoint}.

The \textbf{API Entrypoint} forwards the request to the \textbf{PathManager},
which first verifies that the path exists and that the requesting user is its owner.
This verification is performed by querying the database through the
\textbf{QueryManager}. If the path does not exist, a \textbf{404 NOT\_FOUND} response
is generated. If the user is not authorised to delete the path, the backend returns
a \textbf{403 FORBIDDEN} response.

If the ownership check succeeds, the \textbf{PathManager} performs the deletion
by issuing a cascade delete operation through the \textbf{QueryManager},
which removes the path from the \textbf{DBMS}. Upon successful deletion,
the backend returns a \textbf{204 NO\_CONTENT} response.
The mobile app then confirms the successful removal of the path to the user.
If a network or server error occurs during the process, the app displays
a corresponding error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/delete_path.png}
	\caption{Delete a Path Sequence Diagram}
	\label{fig:use_case_delete_path}
\end{figure}
\pagebreak

\subsubsection*{[UC12] - Start a Trip as Guest User}

When a guest user starts a trip using the BBP mobile app, he first selects a path
from the available options. The mobile app displays the selected path on the map
and continuously receives position updates from the \textbf{GPS module} while the 
user is moving and updates the map accordingly.

If at any point the GPS signal is lost, the GPS module reports the error and the
mobile app displays a corresponding warning to the user, interrupting the normal
tracking flow.
No interaction with the backend occurs in this use case. Guest trips are not
associated with a persistent trip identifier and are not stored by the system.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_guest.png}
	\caption{Start a Trip as Guest User Sequence Diagram}
	\label{fig:use_case_start_trip_guest}
\end{figure}
\pagebreak

\subsubsection*{[UC13] - Start a Trip in Manual Mode as a Logged-in User}

In this scenario, a logged-in user starts a trip by selecting a path from the mobile app.
The selected path is displayed on the map, and the user is prompted to enable
\textbf{automatic mode}. The user explicitly declines this option, choosing to
proceed in manual mode.
GPS tracking starts and the device periodically provides position updates.

During the trip, the mobile app stores the collected samples locally and updates the
map in real time. A trip identifier is generated and maintained locally by the app
during tracking and is not sent to the backend at this stage.
If the GPS signal is lost at any point, the GPS module reports the error and the mobile
app displays a corresponding warning to the user, interrupting the tracking process.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_manual.png}
	\caption{Start a Trip in Manual Mode as a Logged-in User Sequence Diagram}
	\label{fig:use_case_start_trip_manual_logged}
\end{figure}
\pagebreak

\subsubsection*{[UC14] - Start a Trip in Automatic Mode as a Logged-in user}

When a logged-in user selects a path and chooses to enable \textbf{automatic mode},
the mobile app displays the selected path and attempts to establish a connection with
the required \textbf{external sensors}.
If the connection to the external sensors fails, the mobile app immediately notifies
the user with an error message and the trip does not start. 

If the connection succeeds, the GPS module periodically sends position updates,
which the mobile app stores locally and reflects on the map in real time. The trip
identifier is generated and maintained locally during tracking and is sent to the
backend only when the trip is stopped and finalised.
During the trip, if the GPS signal is lost, the tracking loop is interrupted and the
user is notified. If instead the connection to the external sensors drops while the
trip is ongoing, the app stops the automatic mode and displays a corresponding error
message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/start_automatic.png}
	\caption{Start a Trip in Automatic Mode as a Logged-in User Sequence Diagram}
	\label{fig:use_case_start_trip_automatic_logged}
\end{figure}
\pagebreak

\subsubsection*{[UC15] - Stop a Trip as Guest User}

This use case describes how a guest user stops an ongoing trip.
Since guest trips are not stored on the backend, the entire interaction
is handled locally by the mobile application.

The process starts when the user selects the \textbf{Stop Trip} action.
The mobile app ends the trip visualisation and updates the user interface accordingly.
No network communication is performed and no data is persisted,
as guest trips are not associated with a backend record.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{Images/Sequence_Diagrams/stop_guest.png}
	\caption{Stop a Trip as a Guest User Sequence Diagram}
	\label{fig:use_case_stop_trip_guest}
\end{figure}
\pagebreak

\subsubsection*{[UC16] - Stop a Trip as a Logged-in User}

A logged-in user wants to stop an ongoing trip.
The interaction begins when the user selects the \textbf{Stop Trip} action
from the mobile app. The app first terminates any active data acquisition and,
if the trip was started in automatic mode, external sensor connections. The
collected data is then validated. If the validation succeeds, the mobile app
sends a finalisation request to the backend through the \textbf{API Entrypoint}.
The \textbf{TripManager} processes the request.

When the trip is valid and the external service is reachable, the
\textbf{TripManager} retrieves a weather snapshot through the
\textbf{WeatherService} based on the trip samples. It also invokes the
\textbf{StatsManager} to compute and aggregate trip statistics and update user's overall statistics,
which are then stored in the database through the \textbf{QueryManager}.

Finally, the \textbf{TripManager} creates the trip record by sending the complete
trip payload, including weather data, to the \textbf{QueryManager}.

Upon successful completion, the backend responds with a \textbf{201 Created}
status. The mobile app displays a success message to the user.
Network failures or server-side errors trigger the corresponding
alternative flows.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/stop_loggedin.png}
	\caption{Stop a Trip as a Logged-in User Sequence Diagram}
	\label{fig:use_case_stop_trip_loggedin}
\end{figure}
\pagebreak

\subsubsection*{[UC17] - Make a Report in Manual Mode}

When a logged-in user wants to manually report an issue encountered on a path,
the user opens the report creation form on  the mobile application.
The app retrieves the current position from the \textbf{GPS module}.

The user fills in the report form by providing report details,
then submits the report. Before contacting the backend, the mobile app performs
a \textbf{local validation} to ensure that all mandatory fields are correctly filled.
If validation fails, the app shows an error message and no request is sent.
When the input is valid, the mobile app sends a \textbf{POST request} containing the
report payload to the backend through the \textbf{API Entrypoint}. In case of network
timeouts or server-side failures, the app notifies the user accordingly.

The \textbf{API Entrypoint} forwards the request to the \textbf{ReportManager}, which
creates the report by storing the user identifier, the associated path, the position,
and the report data through the \textbf{QueryManager}. The \textbf{DBMS} generates a
new report identifier and confirms the insertion.
Upon success, the backend returns a \textbf{201 Created} response with the report identifier,
and the mobile app displays a confirmation message to the user.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_manual.png}
	\caption{Make a Report in Manual Mode Sequence Diagram}
	\label{fig:use_case_report_problem_manual}
\end{figure}
\pagebreak

\subsubsection*{[UC18] - Make a Report in Automatic Mode}

During an ongoing trip with automatic mode enabled, external sensors may automatically detect an obstacle or issue
on the path. When such a detection occurs, the mobile app retrieves the current position
from the \textbf{GPS module}. If the GPS position cannot be obtained, the app displays an
error message and the reporting flow terminates.

If the position retrieval succeeds, the app displays a pre-filled report form containing
the detected issue information. The user can review, modify, or complete the report details
before submission.
After confirmation, the mobile app performs a \textbf{local validation} of the generated
report data. If the payload is invalid or incomplete, an error is shown and the backend
is not contacted.

When validation succeeds, the app sends the report payload to the backend via the
\textbf{API Entrypoint}. Network or server errors result in a timeout and an appropriate
error message is displayed to the user.
The \textbf{ReportManager} receives the request and creates a new report by delegating
its persistence to the \textbf{QueryManager}, which inserts the record into the
\textbf{DBMS}. After successful insertion, the backend responds with a
\textbf{201 Created} status.
Finally, the mobile app informs the user that the report has been submitted successfully.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_automatic.png}
	\caption{Make a Report in Automatic Mode Sequence Diagram}
	\label{fig:use_case_report_problem_automatic}
\end{figure}
\pagebreak

\subsubsection*{[UC19] - Confirm a Report}

While a logged-in user is travelling, the system may notify him of an existing report
located nearby. The mobile app displays a confirmation form, allowing the user to either
confirm, reject, or dismiss the reported issue.
If the user ignores the notification, the form is dismissed after a short period of time
and no further action is taken. If the user submits a decision, the mobile
app performs a \textbf{local validation} to ensure that the input is valid.

When validation succeeds, the app sends the confirmation (or rejection) request to the backend through
the \textbf{API Entrypoint}. In case of network or server errors, an appropriate error
message is shown to the user.
The \textbf{API Entrypoint} forwards the request to the \textbf{ReportManager}, which creates
a report entry. The confirmation is persisted through the \textbf{QueryManager} by inserting the record
into the \textbf{DBMS}.

If the operation completes successfully, the backend responds with a
\textbf{201 Created} status and returns the confirmation identifier.
The mobile app then notifies the user that the confirmation has been submitted successfully.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/report_confirm.png}
	\caption{Confirm a Report Sequence Diagram}
	\label{fig:use_case_confirm_other_reports}
\end{figure}
\pagebreak

\subsubsection*{[UC20] - View Trip History}

When a logged-in user opens the trip history section from the mobile application,
the mobile app sends a request to the backend through the \textbf{API Entrypoint}
to retrieve the list of trips associated with the user.
The \textbf{API} forwards the request to the \textbf{TripManager}, which
retrieves the user identifier and queries the database through the
\textbf{QueryManager}. The \textbf{DBMS} returns the list of trips linked
to the user account.
For each trip in the list, the \textbf{TripManager} may enrich missing data.
If weather data is missing, it invokes the \textbf{WeatherService} to compute
a snapshot and stores it back through the \textbf{QueryManager}. It also requests
the relevant reports via the \textbf{ReportManager} so they can be shown on the map.
If statistics are missing, it delegates to the \textbf{StatsManager}, which
computes and aggregates the statistics and then persists them via the
\textbf{QueryManager} before responding.

If one or more trips are found, the backend responds with a \textbf{200 OK}
status containing the trip list, and the mobile app displays the history
to the user.
If no trips are found, the backend responds with a \textbf{200 OK} status
containing an empty list, and the mobile app shows an empty state message.

In case of network or server failures, the request times out and the
mobile app notifies the user that the service is unavailable.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/trip_history.png}
	\caption{View Trip History Sequence Diagram}
	\label{fig:use_case_view_trip_history}
\end{figure}
\pagebreak

\subsubsection*{[UC21] - Delete a Trip}

A logged-in user wants to permanently delete one of his recorded trips.
He selects a trip to delete from the mobile application. The app sends a \textbf{DELETE}
request to the backend through the \textbf{API Entrypoint}.

The \textbf{API Entrypoint} forwards the request to the \textbf{TripManager},
which first verifies that the trip exists and that the requesting user is its owner.
This verification is performed by querying the database through the
\textbf{QueryManager}. If the trip does not exist, the backend answers with a
\textbf{404 NOT\_FOUND} response. If the user is not the owner of the trip,
a \textbf{403 FORBIDDEN} response is generated.

If the ownership check succeeds, the \textbf{TripManager} performs the deletion
by issuing a cascade delete operation through the \textbf{QueryManager},
which removes the trip from the \textbf{DBMS}. Upon successful deletion,
the backend returns a \textbf{204 NO\_CONTENT} response.
The mobile app then confirms the successful removal of the trip to the user.
If a network or server error occurs during the process, the app displays
a corresponding error message.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/delete_trip.png}
	\caption{Delete a Trip Sequence Diagram}
	\label{fig:use_case_delete_trip}
\end{figure}
\pagebreak

\subsubsection*{[UC22] - View Overall Statistics}

A logged-in user opens the overall statistics section from the mobile app.
The application sends a request to the backend through the \textbf{API Entrypoint}
to retrieve aggregated statistics across all user trips.

The \textbf{API} delegates the request to the \textbf{StatsManager}, which
first checks whether previously computed overall statistics are still valid
by comparing the stored trip count with the current number of trips retrieved
through the \textbf{QueryManager}.

If valid statistics already exist, they are loaded from the database and
returned to the mobile app with a \textbf{200 OK} response.
If the stored data is outdated, the \textbf{StatsManager} retrieves
all trip records from the \textbf{DBMS}, computes the aggregated metrics
(e.g., total distance, total duration, average speed), stores the updated
statistics, and returns the results to the client.

If no trips exist for the user, the backend responds with a
\textbf{200} status, and an empty statistics object is returned.
Any network or server-side failure results in a timeout and an error message
displayed on the client.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Sequence_Diagrams/stats_overall.png}
	\caption{View Overall Statistics Sequence Diagram}
	\label{fig:use_case_view_overall_statistics}
\end{figure}
\pagebreak

% --------------------------------------------------------------------------
% Component Interfaces
% --------------------------------------------------------------------------

\section{Component Interfaces}
\label{sec:component_interfaces}

This section describes the operations exposed by each backend component and the
interfaces through which these components collaborate at runtime.

The \textbf{API Entrypoint} exposes the REST endpoints used by the mobile app and routes
each request to the correct Manager or Service.
Unless explicitly noted, most Manager methods operate in an authenticated context:
the identifier of the currently logged-in user is implicitly supplied by the
\textbf{API Entrypoint} after validating the access token, and is therefore not
included in the method signatures. Public endpoints (e.g., registration, login,
and path search) are invoked without an authenticated context.
The \textbf{QueryManager}, in contrast, interacts directly with the relational DBMS
and does not rely on authentication parameters.

\subsection*{User Module - AuthManager}
The \textbf{AuthManager} handles user authentication, credential verification,
token generation, and logout flows.
It is invoked through the \textbf{API Entrypoint} and relies on the \textbf{QueryManager}
to retrieve and persist authentication metadata, including refresh tokens stored in the DBMS.

It exposes the following operations:

\begin{itemize}
	\item \textbf{loginUser(email, password)}: verifies the supplied credentials and, if valid, issues fresh access and refresh
	      tokens and persists the new refresh token.
	\item \textbf{logout(refreshToken)}: invalidates the provided refresh token and terminates the associated session in the DBMS.
\end{itemize}

\subsection*{User Module - UserManager}
The \textbf{UserManager} manages user-profile data and receives requests via the
\textbf{API Entrypoint}.
It uses the \textbf{QueryManager} for persistence and exposes:

\begin{itemize}
	\item \textbf{registerUser(profilePayload)}: validates registration data, checks for duplicate email/username, stores the user profile, and returns the created user.
	\item \textbf{updateProfile(userId, profilePayload)}: validates editable fields, prevents duplicate emails/usernames, applies the update, and returns a confirmation message.
\end{itemize}

\subsection*{PathManager}

The \textbf{PathManager} implements all functionality related to bike paths:
manual path creation, route search, ranking of candidate routes,
path selection, deletion, and visibility updates.
It is accessed through the \textbf{API Entrypoint} and uses the \textbf{QueryManager}
to retrieve and update persistent path data. When manual path creation requires
snapping, it invokes the \textbf{SnappingService}. The \textbf{API Entrypoint} also
exposes a dedicated snapping endpoint that forwards coordinates to this component.

The public operations are:

\begin{itemize}
	\item \textbf{findPath(origin, destination, userId?)}: geocodes origin/destination, filters existing paths by visibility and proximity, and returns matching routes.
	\item \textbf{createPath(pathPayload, userId)}: validates metadata and path segments (manual or automatic mode), persists the new path, and associates it with the creator.
	\item \textbf{snapPath(coordinates)}: forwards coordinates to the \textbf{SnappingService} and returns the adjusted polyline.
	\item \textbf{getPathsByUser(userId)}: retrieves all paths created by the authenticated user.
	\item \textbf{deletePath(pathId, userId)}: verifies ownership and removes the specified path, triggering cascade deletion of dependent records.
	\item \textbf{updateVisibility(pathId, visibility, userId)}: enforces ownership and updates the stored visibility field.
\end{itemize}

\subsection*{TripManager}

The \textbf{TripManager} coordinates the lifecycle of a cycling session.
It receives trip metadata (origin/destination, timestamps, trip segments) from the mobile app and
persists it through the \textbf{QueryManager}. Weather enrichment is performed via the
\textbf{WeatherService} on demand.

The component exposes the following methods:

\begin{itemize}
	\item \textbf{finalizeTrip(tripPayload, userId)}: stores a completed trip and triggers weather/statistics enrichment when required.
	\item \textbf{getTripsByUser(userId)}: returns the complete list of trips owned by the authenticated user, ordered by time, enriching missing weather, statistics, and reports when needed.
	\item \textbf{deleteTrip(tripId, userId)}: deletes the specified trip after verifying ownership.
\end{itemize}

\subsection*{ReportManager}

The \textbf{ReportManager} handles obstacle reporting and confirmation flows.
It is invoked by the \textbf{API Entrypoint} and also by the \textbf{TripManager}
when trip summaries need to be enriched with associated reports.
All persistence is delegated to the \textbf{QueryManager}.

\begin{itemize}
	\item \textbf{getPathReports(pathId)}: retrieves reports associated with a selected path.
	\item \textbf{createReport(reportPayload, userId)}: stores a new report, either manual or automatic.
\end{itemize}

\subsection*{StatsManager}

The \textbf{StatsManager} computes and retrieves aggregated metrics for trips and overall history.
It is called by the \textbf{API Entrypoint} and by the \textbf{TripManager} at trip finalization,
and also during trip retrieval when statistics are missing and need to be computed on demand.

\begin{itemize}
	\item \textbf{getOverallStats(userId)}: returns cached overall statistics if valid, otherwise recomputes and stores them.
	\item \textbf{generateStats(tripPayload)}: calculates per-trip and updates the user's overall statistics based on the provided trip data.
\end{itemize}

\subsection*{WeatherService}

The \textbf{WeatherService} interfaces with an external weather provider and is used by the
\textbf{TripManager} to enrich trip summaries with environmental context at trip finalization,
and again during trip retrieval if stored weather data is missing.

\begin{itemize}
	\item \textbf{fetchAndAggregateWeatherData(tripPayload)}: samples coordinates along the trip route, fetches point data, and returns an aggregated snapshot.
\end{itemize}

\subsection*{GeocodingService}

The \textbf{GeocodingService} resolves user-provided location strings to coordinates
used by the \textbf{PathManager}.

\begin{itemize}
	\item \textbf{geocode(locationString)}: returns coordinates for a textual location.
\end{itemize}

\subsection*{SnappingService}

The \textbf{SnappingService} aligns user-drawn segments to the road network and returns
the adjusted polyline to the \textbf{PathManager}.

\begin{itemize}
	\item \textbf{snapToRoad(segment)}: snaps a path segment to the road network.
\end{itemize}

\subsection*{QueryManager}

The \textbf{QueryManager} is the uniform access point to the DBMS.
It encapsulates all SQL operations required by the Managers, ensuring consistency and
separation between domain logic and data storage.

It exposes:

\begin{itemize}
	\item \textbf{checkDuplicateEmail(email)}: checks if an account with the given email already exists.
	\item \textbf{checkDuplicateUsername(username)}: checks if a username is already taken.
	\item \textbf{checkEmail(email)}: retrieves user data by email for authentication.
	
	\item \textbf{saveRefreshToken(token)}: stores a refresh token.
	\item \textbf{insertUser(profilePayload)}: stores a new user record.
	\item \textbf{insertReport(position, payload)}: inserts a new report record.
	\item \textbf{insertTripSummary(tripSummary, userId)}: inserts a completed trip summary.
	\item \textbf{insertTripStats(tripStats, userId)}: inserts trip statistics.
	\item \textbf{insertOverallStats(stats, userId)}: inserts overall statistics for a user.
	\item \textbf{insertPath(pathPayload, userId)}: inserts a path with specified metadata, segments and visibility.
	
	\item \textbf{deleteRefreshToken(token)}: deletes a refresh token.
	\item \textbf{deleteTrip(tripId)}: deletes a trip and all dependent records.
	\item \textbf{deletePath(pathId)}: deletes a path and all dependent records.
	
	\item \textbf{updatePathVisibility(pathId, visibility)}: updates the visibility of a path.
	\item \textbf{updateOverallStats(userStats, userId)}: update user's overall statistics.
	\item \textbf{updateUser(userId, profilePayload)}: updates editable user profile fields.
	
	\item \textbf{fetchUserPaths(userId)}: retrieves all paths created by a user.
	\item \textbf{fetchPaths(origin, destination, userId)}: retrieves paths matching the specified area and visibility constraints.
	\item \textbf{fetchReportsByTripId(tripId)}: retrieves reports associated with a trip.
	\item \textbf{fetchStats(userId)}: retrieves overall statistics for a user.
	\item \textbf{fetchTripCount(userId)}: retrieves the total number of trips for a user.
	\item \textbf{fetchUserTrips(userId)}: retieves all trips associated with a user.
	\item \textbf{fetchAggregatedWeatherData(tripId)}: retrieves stored weather data for a trip.
	\item \textbf{fetchReportsByPathId(pathId)}: retrieves reports for a path.
	
	\item \textbf{verifyPathOwnership(pathId, userId)}: verifies that a path belongs to the specified user.
	\item \textbf{verifyTripOwnership(tripId, userId)}: verifies that a trip belongs to the specified user.

\end{itemize}

\subsection{RESTful API endpoints}
\label{sec:api_endpoints}

The BBP backend exposes a RESTful API consumed by the mobile application.
All endpoints exchange JSON payloads over HTTPS and are versioned under the base path \texttt{/api/v1}.
Unless otherwise specified, requests that access or modify user-specific resources require authentication via
\texttt{Authorization: Bearer <access\_token>}. Refresh tokens are used to renew expired access tokens.

Each endpoint definition reports the HTTP method, the resource path, the expected request parameters (query/path/body),
and the possible responses. Standard HTTP status codes are adopted to represent successful outcomes and errors.


\subsubsection*{Auth}
\paragraph{\textbf{POST} \texttt{/api/v1/auth/login}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ email, password \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, user, tokens \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}, \texttt{MISSING\_CREDENTIALS}
		      \item \textbf{401 Unauthorized}: \texttt{INVALID\_CREDENTIALS}
		      \item \textbf{404 Not Found}: \texttt{USER\_NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\paragraph{\textbf{POST} \texttt{/api/v1/auth/logout}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ refreshToken \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{204 No Content}
			  \item \textbf{401 Unauthorized}: \texttt{MISSING\_REFRESH\_TOKEN}
		  \item \textbf{403 Forbidden}: \texttt{INVALID\_REFRESH\_TOKEN}, \texttt{REFRESH\_TOKEN\_NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\subsubsection*{Users}
\paragraph{\textbf{POST} \texttt{/api/v1/users/register}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ email, password, username, systemPreferences? \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{201 Created}: \texttt{\{ success, user \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}, \texttt{MISSING\_CREDENTIALS}
		      \item \textbf{409 Conflict}: \texttt{EMAIL\_ALREADY\_IN\_USE}, \texttt{USERNAME\_ALREADY\_IN\_USE}
	      \end{itemize}
\end{itemize}

\paragraph{\textbf{PATCH} \texttt{/api/v1/users/me}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ username?, email?, currentPassword?, password?, systemPreferences? \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, message \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}, \texttt{EMPTY\_PAYLOAD}, \texttt{CURRENT\_PASSWORD\_REQUIRED}, \texttt{INCORRECT\_PASSWORD}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
			  \item \textbf{409 Conflict}: \texttt{EMAIL\_ALREADY\_IN\_USE}, \texttt{USERNAME\_ALREADY\_IN\_USE}
	      \end{itemize}
\end{itemize}

\subsubsection*{Paths}
\paragraph{\textbf{POST} \texttt{/api/v1/paths}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ pathSegments, visibility, creationMode, title, description \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{201 Created}: \texttt{\{ success, message, data \}}
		  \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}
		  \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		  \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		      \end{itemize}
\end{itemize}

\paragraph{\textbf{GET} \texttt{/api/v1/paths/search}}
\begin{itemize}
	\item \textbf{Query Params}: \texttt{origin}, \texttt{destination}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}, \texttt{GEOCODE\_NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\paragraph{\textbf{POST} \texttt{/api/v1/paths/snap}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ coordinates \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}

		     \end{itemize}
\end{itemize}

\paragraph{\textbf{GET} \texttt{/api/v1/paths}}
\begin{itemize}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}} 
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		  \end{itemize}
\end{itemize}

\paragraph{\textbf{PATCH} \texttt{/api/v1/paths/:pathId/visibility}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ visibility \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, message, data \}}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{FORBIDDEN}
		      \item \textbf{404 Not Found}: \texttt{NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\paragraph{\textbf{DELETE} \texttt{/api/v1/paths/:pathId}}
\begin{itemize}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{204 No Content}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{FORBIDDEN}
		      \item \textbf{404 Not Found}: \texttt{NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\subsubsection*{Trips}
\paragraph{\textbf{POST} \texttt{/api/v1/trips}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ origin, destination, startedAt, finishedAt, tripSegments, title? \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{201 Created}: \texttt{\{ success, message, data \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}, \texttt{INVALID\_DATES}, \texttt{INVALID\_DATE\_RANGE}, \texttt{DUPLICATE\_SEGMENT\_IDS}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		       \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		  \end{itemize}
\end{itemize}

\paragraph{\textbf{GET} \texttt{/api/v1/trips}}
\begin{itemize}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}} 
			   \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		  \end{itemize}
\end{itemize}

\paragraph{\textbf{DELETE} \texttt{/api/v1/trips/:tripId}}
\begin{itemize}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{204 No Content}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{FORBIDDEN}
		      \item \textbf{404 Not Found}: \texttt{NOT\_FOUND}
	      \end{itemize}
\end{itemize}

\subsubsection*{Reports}
\paragraph{\textbf{GET} \texttt{/api/v1/reports}}
\begin{itemize}
	\item \textbf{Query Params}: \texttt{pathId}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}} 
		  \end{itemize}
\end{itemize}

\paragraph{\textbf{POST} \texttt{/api/v1/reports}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ segmentId, sessionId, obstacleType, position, pathStatus? \}} (or \texttt{condition})
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{201 Created}: \texttt{\{ success, message, data \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}
		      \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		   \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		     
			\end{itemize}
\end{itemize}

\paragraph{\textbf{POST} \texttt{/api/v1/reports/:reportId/confirm}}
\begin{itemize}
	\item \textbf{Request Body}: \texttt{\{ decision, tripId?, sessionId? \}}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{201 Created}: \texttt{\{ success, message, data \}}
		      \item \textbf{400 Bad Request}: \texttt{VALIDATION\_ERROR}
			   \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		  \end{itemize}
\end{itemize}

\subsubsection*{Stats}
\paragraph{\textbf{GET} \texttt{/api/v1/stats}}
\begin{itemize}
	\item \textbf{Responses}:
	      \begin{itemize}
		      \item \textbf{200 OK}: \texttt{\{ success, data \}}
			  \item \textbf{401 Unauthorized}: \texttt{ACCESS\_TOKEN\_MISSING}
		      \item \textbf{403 Forbidden}: \texttt{INVALID\_ACCESS\_TOKEN}
		  \end{itemize}
\end{itemize}

% --------------------------------------------------------------------------
% Architectural Styles and Patterns
% --------------------------------------------------------------------------

\section{Selected Architectural Styles and Patterns}
\label{sec:arch_patterns}%

The BBP system adopts a \textbf{three-tier, layered architecture} composed of a thin mobile client,
an application tier implementing all business rules, and a relational data tier.
This structure ensures clear responsibility separation, simplifies maintenance,
and supports the mobile-first design goals described in the system overview.

\begin{itemize}
	\item \textbf{API Entrypoint with modular backend}.
	      All external requests pass through the \textbf{API Entrypoint}, which centralises routing, authentication,
	      input validation and error normalisation.
	      Behind it, the backend is organised as a collection of Managers, each encapsulating
	      a coherent vertical slice of functionality (paths, reports, trips, users).
	      This separation reduces coupling, facilitates parallel development, and keeps
	      inter-component interactions lightweight.

	\item \textbf{RESTful, stateless communication}.
	      The mobile app interacts with the backend exclusively through resource-based HTTPS
	      endpoints.
	      The application tier remains stateless for access tokens: session information is kept client-side through
	      short-lived access tokens stored in secure storage, making the system horizontally scalable
	      and resilient to server restarts. Refresh tokens are persisted in the DBMS to support logout and rotation,
	      introducing minimal server-side state explicitly managed by the \textbf{AuthManager}.

	\item \textbf{Service Layer pattern}.
	      Each Manager acts as a well-defined service boundary that hides internal logic,
	      aggregates operations into meaningful methods, and exposes a stable API to the \textbf{API Entrypoint}.
	      This pattern avoids exposing domain details to the controller layer and fosters
	      maintainability and testability.

	\item \textbf{DAO pattern}.
	      The \textbf{QueryManager} centralises access to the relational DBMS and hides SQL concerns
	      from the rest of the backend.
	      By enforcing consistency checks and persistence rules in a single component, the system
	      becomes less error-prone and more adaptable to future schema evolution or database
	      optimisation.

	\item \textbf{Security patterns}.
	      Authentication is based on JWT-like tokens validated by the \textbf{API Entrypoint} (middleware),
	      while the AuthManager handles token issuance, refresh, and logout flows.
	      Boundary validation prevents malformed inputs and mitigates injection risks.
	      Authorisation is enforced by combining token claims with ownership checks on persisted
	      resources, keeping backend nodes stateless and interchangeable while preserving access
	      control guarantees.
\end{itemize}

% --------------------------------------------------------------------------
% Other Design Decisions
% --------------------------------------------------------------------------

\section{Other Design Decisions}
\label{sec:other_design_decisions}%

Beyond the architectural style, the following design choices strengthen the BBP system's
quality attributes and align with the mobile-first scope:

\begin{itemize}
	\item \textbf{Authentication and authorisation}.
	      Access control relies on short-lived access tokens and refresh tokens securely stored
	      on the mobile client. Refresh tokens are also persisted in the DBMS to enable validation,
	      rotation, and logout.
	      The API Entrypoint enforces authentication, while domain-level authorisation (guest vs
	      authenticated user) is performed inside the Managers.

	\item \textbf{Validation and error handling}.
	      Validation occurs at the system boundary (API Entrypoint) ensuring malformed
	      (e.g. missing JWT, invalid JSON schema) or invalid endpoint requests
	      are filtered before reaching the business layer.
	      On the other hand, user input is validated when the request reaches the
	      business layer, ensuring that incomplete or incorrect data will not be saved, and
	      the user will be correctly notified.
	      Errors are normalised into structured HTTP responses so the mobile client can present
	      consistent messages. Domain-specific errors (e.g., \texttt{NOT\_FOUND}) are explicitly
	      mapped and surfaced through the \textbf{API Entrypoint}.

	\item \textbf{Fault tolerance}.
	      Calls to external services (e.g., weather provider) are wrapped with timeouts,
	      and explicit error handling. When external data cannot be retrieved,
	      the system either returns a safe default (e.g., empty weather aggregation) or
	      propagates a domain error depending on the operation.
	      Even in case of partial failure, critical user actions (such as trip completion) are
	      preserved and stored.

	\item \textbf{Data integrity}.
	      The \textbf{QueryManager} centralises data access and consistency checks. Atomicity
	      for multi-step operations is enforced at the application level by validating inputs
	      before persistence and by performing guarded updates, while keeping SQL concerns
	      encapsulated within the data-access layer.

\end{itemize}
