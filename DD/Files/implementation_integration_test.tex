% --------------------------------------------------------------------------
% Implementation and Integration Test Plan
% --------------------------------------------------------------------------

% --------------------------------------------------------------------------
% Implementation Plan
% --------------------------------------------------------------------------
\section{Overview}
This chapter outlines the strategies adopted for the implementation, integration, and testing of the \textbf{Best Bike Paths (BBP)} platform.
The primary objective is to ensure that the system meets the functional and non-functional requirements defined in the RASD document.

The chosen integration and testing strategy is a mix of a \textbf{Thread} approach and a \textbf{Bottom-Up} approach. 
In practice, we develop and test starting from low-level components and then progressively move upward toward more complex business-logic components.

By following a thread-based implementation, we can build and validate independent components \textbf{quickly and in parallel}, 
and start integration testing early instead of waiting for major modules (e.g., \textit{PathManager} or \textit{ReportManager}) 
to be fully completed. At the same time, for components that require more time and have strong dependencies such as \textit{TripManager}, 
which relies on \textit{PathManager} and \textit{StatsManager}, or \textit{ReportManager}, which depends on both \textit{PathManager} and \textit{TripManager}, a 
Bottom-Up progression is more suitable, since these modules can be integrated only once the underlying layers and required managers are stable.

This combined strategy helps us identify and resolve integration issues earlier, reducing the risk of costly problems emerging later in development.

\section{Implementation Plan}
The implementation of the BBP backend will follow a three-tier architecture (Data, Application, Presentation), developed iteratively.

\subsection{Development Environment and Tools}
Before starting the coding of modules, the development environment will be set up:
\begin{itemize}
    \item \textbf{Version Control}: Use of Git with a feature-branch workflow.
    \item \textbf{DBMS Setup}: Configuration of the PostgreSQL instance and definition of relational schemas. 
                            For this purpose, we will use the free tier cloud version of PostgreSQL offered by Prisma.
    \item \textbf{CI/CD}: Configuration of pipelines for automated building and testing.
\end{itemize}

\subsection{Implementation Order}
The implementation order of software components will be as follows:
\begin{enumerate}
    \item \textbf{Data Access Layer}: Implementation of the \texttt{QueryManager} and database configuration. Inside the QueryManager, 
                                    we will implement the necessary CRUD operations as we implement each specific manager.
    \item \textbf{External Services Integration}: Implementation of the \texttt{Geocoding}, \texttt{Weather} and \texttt{Snapping} services 
                                    for communication with external weather APIs.
    \item \textbf{Core Services}: Development of \texttt{AuthManager} and \texttt{UserManager} for identity management.
    \item \textbf{Business Logic Services}: \texttt{PathManager} can be implemented independently.
                                    Then we will develop \texttt{TripManager}, \texttt{StatsManager}, and \texttt{ReportManager} 
                                    in this order.
    \item \textbf{Interface Layer}: Definition of REST endpoints and configuration of the external access layer (Cloudflare 
                                    for DNS/TLS termination and NGINX reverse proxy routing to the backend).
    \item \textbf{Presentation Layer}: Development of the \texttt{Mobile App} (developed in parallel using Mock APIs in the initial stages).
\end{enumerate}

% --------------------------------------------------------------------------
% Integration Plan
% --------------------------------------------------------------------------

\section{Integration Plan}
\label{sec:integration_plan}%
Each \texttt{Manager} denotes a backend module within the Application Tier (i.e., part of the BBP backend), rather than an independently deployed microservice.
Each phase integrates one or more modules into the existing subsystem and verifies their correct behavior through a dedicated
test driver that simulates invocations from higher layers.
Following a mixed \textit{thread-based} and \textit{bottom-up} strategy, we integrate independent components early,
while managers with stronger dependencies are added progressively on top of already stable lower-level modules.
Whenever external dependencies are involved (e.g., Weather/Geocoding/Snapping APIs), stubs/mocks are adopted to keep tests reproducible.

The first step consists of integrating the \texttt{DBMS} with the \texttt{QueryManager}. Since all subsequent managers depend on
data access, this subsystem constitutes the foundation of the architecture.
The test driver will simulate query requests (CRUD) to verify correct connectivity, schema constraints, transactions, and
the manipulation of persistent data. Additionally, database migrations will be applied automatically as part of the test setup
to ensure a clean and consistent initial state across runs.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.20\textwidth]{../Images/iit/iit1.png}
    \caption{Step 1: DBMS and QueryManager Integration}
    \label{fig:iit1}
\end{figure}


The \texttt{AuthManager} and \texttt{UserManager} are integrated next. These components are fundamental to ensure that subsequent operations
are performed by authenticated users. The driver will simulate registration, login, logout and profile management, verifying that the
\texttt{QueryManager} correctly persists credentials and user data and that token generation, validation, and error conditions
(e.g., duplicate e-mails, invalid credentials, revoked/expired tokens) are handled consistently.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.50\textwidth]{../Images/iit/iit2.png}
    \caption{Step 2: AuthManager and UserManager Integration}
    \label{fig:iit2}
\end{figure}


In parallel, we integrate the external services used by the backend, namely \texttt{Weather}, \texttt{Geocoding}, and \texttt{Snapping}.
Since these components primarily interact with external APIs and have minimal internal dependencies, they can be also tested independently.
The driver will rely on stubbed endpoints to simulate both successful and failing API calls, verifying correct
request formatting, response parsing, and robust handling of timeouts and HTTP errors. Meaningful error codes must be propagated
when an external service is unavailable.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{../Images/iit/iit3.pdf}
    \caption{Step 3: External Services Integration (Weather/Geocoding/Snapping)}
    \label{fig:iit3}
\end{figure}


We proceed with the integration of the \texttt{PathManager}. This component is crucial for BBP's core logic (path management). 
The driver will test the creation of new paths and the route calculation process, which relies on geospatial data retrieved
via the \texttt{QueryManager}. Integration tests will also verify that the \texttt{PathManager} correctly computes and ranks
candidate routes using stored path and report information, and properly handles corner cases such as missing, stale or incomplete data.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{../Images/iit/iit4.pdf}
    \caption{Step 4: PathManager Integration}
    \label{fig:iit4}
\end{figure}


The \texttt{TripManager} is added next. This module manages user trips and relies on the \texttt{PathManager} 
and the weather external service to associate contextual data with each trip. 
Integration tests will verify that raw trip samples and metadata are correctly stored, that each trip is linked to the 
selected path and corresponding weather snapshot, and that a complete trip summary is generated upon closure, 
even if the external weather service is temporarily unavailable.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{../Images/iit/iit5.pdf}
    \caption{Step 5: TripManager Integration}
    \label{fig:iit5}
\end{figure}

After the \texttt{TripManager}, we integrate the \texttt{StatsManager}. This component aggregates data generated
by the user's device to provide statistics. Its integration enables testing data flows based on trips and their associated routes.
Integration tests will exercise interactions involving trips and paths to ensure that computed aggregates are consistent with the underlying data,
preserve referential integrity, and remain efficient on realistic data volumes.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{../Images/iit/iit6.pdf}
    \caption{Step 6: StatsManager Integration}
    \label{fig:iit6}
\end{figure}


After the \texttt{StatsManager}, we integrate the \texttt{ReportManager}. This module allows users to report obstacles.
Integration tests will verify that reports are correctly linked to existing users and paths, that attempts to create reports for non-existing
entities are rejected, and that report updates and confirmations are properly propagated to the \texttt{PathManager} so that route computation
can take report information into account.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{../Images/iit/iit7.pdf}
    \caption{Step 7: ReportManager Integration}
    \label{fig:iit7}
\end{figure}


Finally, the mobile application (front-end) is integrated and used to perform real requests against the backend, replacing the driver.
At this final stage, integration tests are executed end-to-end by exercising the main use cases from the mobile client, including real device sensors
(e.g., GPS), and checking that interactions between the app, backend components, and the database behave as described in the Runtime View sequence diagrams.

\vspace{1cm}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{../Images/iit/iit8.pdf}
    \caption{Step 8: System Integration via HTTP Test Driver}
    \label{fig:iit8}
\end{figure}


% --------------------------------------------------------------------------
% Test Plan
% --------------------------------------------------------------------------

\section{Test Plan}
\label{sec:test_plan}%

Testing activities will be conducted during every development phase to ensure software quality. The testing strategy covers 
individual units, module interactions, and full system behavior.

\subsection{Unit Testing}
Unit testing is the first line of defense against software defects. In this project, we will employ Jest as our primary testing 
framework to isolate and verify the correctness of individual components, specifically the Managers and utility classes. 
The goal is to ensure that the internal logic of methods and classes functions exactly as intended before they interact with other 
parts of the system. For components that rely on external dependencies, such as the database or the external weather service, we will 
utilize Mock Objects. This approach allows us to simulate the behavior of these dependencies, ensuring that tests remain focused and fast.
Particular attention will be devoted to error handling, input validation, and authorization checks at the module boundaries.

\subsection{Integration Testing}
Integration testing will be conducted incrementally following the steps described in Section \ref{sec:integration_plan}. 
The primary objective of this phase is to verify that the interfaces between different components communicate correctly 
and that data flows seamlessly across module boundaries. We will focus on verifying the correct passing of parameters, 
the proper handling of exceptions that may propagate between modules, and the referential integrity of data as it moves 
from the business logic layer to the persistence layer. By testing these interactions early and often, we can identify 
interface mismatches and communication errors that unit tests might miss. When applicable, contract checks will validate the structure
of exchanged payloads (e.g., expected JSON schemas and HTTP status codes at the API Gateway).

\subsection{System Testing}
System testing will be executed on the complete system. This phase involves a rigorous validation of the application against 
the requirements specified in the RASD. Functional testing will cover all use cases to ensure that the user workflows, 
such as creating a trip, reporting an obstacle, or viewing statistics, behave as expected. Additionally, we will perform stress 
testing by simulating a high volume of concurrent requests to critical components like the 
\texttt{PathManager} and \texttt{TripManager}, ensuring the system remains stable under heavy load. Finally, performance 
testing will measure the response times of the API Gateway, with a particular focus on resource-intensive operations like 
route calculation and statistics retrieval, to guarantee a responsive user experience.
