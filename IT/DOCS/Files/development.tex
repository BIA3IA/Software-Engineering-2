
\section{Adopted Frameworks}
\label{sec:frameworks}

The BBP platform relies on a set of technologies selected to cover the needs of the mobile client, the server
side, and the persistence layer. In the sections below, we outline the core frameworks used in each area and
briefly describe their role, key characteristics, and why they were chosen for this project.

\subsection{Mobile App}
\label{sec:mobile_app}

The BBP mobile application is developed with React Native in the Expo ecosystem, allowing a single codebase
to target both iOS and Android while keeping GPS access consistent across devices. Expo also simplifies build
and deployment steps, which reduces overhead during development and testing.

Navigation is handled through Expo Router, which offers file-based routing and keeps screen structure easy to
maintain as the app grows. Global state is managed with Zustand, selected for its minimal boilerplate and
efficient updates, which are important for user session handling.

The user interface relies on React Native Paper to provide a Material Design-compliant component library with
built-in theming support. Lucide Icons supplies a lightweight and consistent icon set, while React Native Maps
is used for the core map experience, including path visualization and score overlays. Expo Linear Gradient is
used in selected screens to provide branded visual accents in the interface.

Location tracking is implemented via Expo Location, which handles permission requests and continuous GPS
updates needed for map views and trip-related features.

For data exchange, Axios manages HTTP requests to the backend. Zod defines schemas for client-side input
validation (e.g., authentication and profile forms) and integrates with React Hook Form via resolvers to
enforce those constraints in the UI. Expo Secure Store persists authentication tokens on device.

\subsection{Backend}
\label{sec:backend}

\textbf{Express.js} Express.js, or simply Express, is a back end web application framework for Node.js, released as free and 
open-source software under the MIT License. It is designed for building web applications and APIs. It has been called the de 
facto standard server framework for Node.js.\cite{enwiki:1331088521}

The main reason for choosing Express.js as the backend framework is because it is very easy-to-use and flexible, together with 
its ability to maintain high performance while offering a comprehensive set of features. Express provides pre-built functions, 
libraries, and tools that help accelerate the web development process.

It has also one of the most powerful and robust routing system that assists your application in responding to a client request via
a particular endpoint. With the routing system in Express.js, we were able to split the routing system into manageable files using 
the framework’s router instance. It is very helpful in managing the application structure grouping different routes into a 
single folder/directory.

ExpressJS uses middleware to process incoming requests before they reach their final destination. This allows us to 
perform tasks such as authentication, validation, and logging in a reusable and modular manner.

\textbf{Jest} is a testing framework for JavaScript applications, developed and maintained by Meta and distributed 
as open-source software.
It provides an all-in-one solution for writing, executing, and maintaining automated tests, including unit tests and integration tests.
Jest includes built-in support for test runners, mocking utilities, and code coverage analysis, reducing the need for additional
external dependencies.

Jest was selected primarily for its integration with modern JavaScript and Node.js environments.
It allowed us to quickly set up a testing environment with minimal overhead, while still offering advanced configuration options 
when needed. The framework supports asynchronous testing out of the box, which is essential for backend applications that rely heavily on 
asynchronous operations such as database access and HTTP requests.

\subsubsection{Technologies used in the Backend}

The backend relies on the following technologies and libraries:

\begin{itemize}
  \item \textbf{Node.js}: JavaScript runtime environment based on the V8 engine, enabling the execution of server-side 
                        applications using an event-driven, non-blocking I/O model that is well suited for scalable backend services\cite{node:Node.js}.
  \item \textbf{Joi}: data validation library used to define schemas for request payloads, ensuring that incoming data conforms to 
                        expected formats and constraints before being processed by the application\cite{node:joi}.
  \item \textbf{bcrypt}: cryptographic hashing library used to securely store user passwords by applying adaptive hashing algorithms,
                        protecting against brute-force and rainbow table attacks\cite{node:bcrypt}.
  \item \textbf{jsonwebtoken}: library used to implement stateless authentication through JSON Web Tokens (JWT), enabling secure 
                        user session management and authorization across API endpoints\cite{node:jsonwebtoken}.
  \item \textbf{cors}: middleware that enables and configures Cross-Origin Resource Sharing, allowing controlled access to backend 
                        resources from client applications hosted on different domains\cite{node:cors}.
  \item \textbf{Pino}: high-performance logging library designed for Node.js applications, used to record structured logs for monitoring,
                        debugging, and auditing purposes\cite{node:pino}.
  \item \textbf{pino-pretty}: development tool used to format Pino logs into a human-readable form, improving log readability during 
                        debugging and local development\cite{node:pino-pretty}.
  \item \textbf{Supertest}: HTTP testing library that allows automated testing of RESTful APIs by simulating HTTP requests and validating 
                        responses without requiring a running network server\cite{node:supertest}.
\end{itemize}


\subsection{Data Layer}
\label{subsec:data_layer}

For data storage and management, the BBP platform relies on \textbf{PostgreSQL} as its primary \textbf{DBMS}. 
This choice is motivated by its proven reliability and by its relational data model, which fits well
with the platform’s core entities, such as users, paths, segments, and trips, and supports the enforcement 
of consistency constraints across related data.

A relational approach is particularly suitable for BBP, where path-related information evolves over time and
must remain consistent despite frequent user-generated updates. \textbf{PostgreSQL} provides the transactional 
guarantees and integrity mechanisms required to manage this evolving dataset in a robust and predictable way.

The interaction between the modular \textbf{NestJS} backend and the database is handled through \textbf{Prisma}, which is 
adopted as the \textbf{ORM}. \textbf{Prisma} generates a type-safe client starting from a single schema
definition, ensuring that database queries are strongly typed and aligned with the \textbf{TypeScript} types 
used throughout the application. This approach helps detect data access errors at compile time and keeps 
the persistence layer consistent as the data model evolves during development.

\section{Adopted Programming Languages}
\label{subsec:languages}

The platform is mainly developed using \textbf{TypeScript}, which is adopted across both the mobile application, 
built with \textbf{React Native} and \textbf{Expo}, and the backend services, built with \textbf{NestJS} and \textbf{Prisma}.
Using a single, strongly typed language
across different layers of the system improves maintainability and reduces the likelihood of runtime 
errors, while also simplifying development workflows.

On the server side, \textbf{TypeScript} integrates smoothly with \textbf{Prisma}, as the generated client types help
identify data access issues at compile time. On the client side, it works well with form validation
and API interaction, making input models and component properties explicit and easier to evolve over time.

Overall, this language choice results in clearer and more robust code, supports safer refactoring, and
reduces the effort required for developers to work across multiple components of the platform.

\section{Development Tools}
\label{sec:dev_tools}

The development workflow is based on \textbf{Node.js} and \textbf{npm}, which are used to manage dependencies and execute 
project scripts for both the backend and the mobile application. On the backend side, \textbf{Docker} and \textbf{Docker
Compose} are adopted to build and run the service in a reproducible and isolated environment, ensuring 
consistency across development and production setups. Database-related tasks, including client generation 
and schema migrations, are handled through the \textbf{Prisma CLI}.

For the mobile application, development and local testing are carried out using the \textbf{Expo CLI}. The \textbf{Expo Go} 
application enables real-time previews on physical devices by scanning the Metro QR code, allowing rapid 
iteration and immediate feedback during development. For distributable builds, the \textbf{EAS CLI} is used to 
generate \textbf{Android} and \textbf{iOS} build artifacts, with APK files produced from the Android build output.

In the production environment, the backend is exposed through a shared \textbf{Nginx} reverse proxy. HTTPS 
termination and certificate management are handled using \textbf{Cloudflare Origin Certificates}, which centralize 
TLS configuration and request routing while keeping backend services isolated from direct internet exposure.

To support integration testing and a shared development workflow, \textbf{EchoAPI} is used to mock and inspect 
backend responses. This tool allows team members to validate client-side behavior against expected API 
outputs, facilitating coordination between frontend and backend development and reducing coupling during 
implementation phases.

\section{API Calls}
\label{sec:api_calls}

Any API not included in the DD should be mentioned here.
