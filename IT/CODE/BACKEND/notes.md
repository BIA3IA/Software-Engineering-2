
# Radom Notes

## 1. Runtime & Language

### Node.js + TypeScript
- High consistency with the mobile app, which is also written in TypeScript.
- Fast learning curve for the whole team.
- Excellent ecosystem for REST APIs.
- Non‑blocking I/O, ideal for applications with frequent network communication.
- Works extremely well with modern backend frameworks (NestJS).

## 2. Backend Framework

### NestJS
- Built with TypeScript in mind.
- Enforces a clean modular architecture: modules, controllers, services.
- Built‑in dependency injection.
- Integrated request validation, pipes, guards, interceptors.
- Swagger documentation support out of the box.
- Structure highly appreciated in academic/enterprise contexts.


### Express.js
- Extremely lightweight.
- Simple and flexible.
- No structure by default.
- Requires manual setup of validation, routing organization, error handling, etc.

### Fastify
- Very fast.
- Modern and modular.
- Smaller ecosystem compared to NestJS.

## 3. Database

### PostgreSQL

- Relational model matches BBP’s entities perfectly (Users, Trips, Paths, Reports…).
- Widely adopted, stable, and easy to manage.
- Supports advanced GIS features via PostGIS, useful for future geo‑routing.
- Great compatibility with Prisma ORM.

### MySQL / MariaDB
- Stable, well‑known relational DBs.
- PostgreSQL generally offers more advanced features.

### MongoDB
- Good for flexible, schema‑less data.
- BBP uses structured, relational data; forcing MongoDB would add complexity.

## 4. ORM / Database Toolkit

### Prisma
- Strong integration with TypeScript.
- Generates fully typed queries -> fewer errors.
- Simple and clear schema file.
- Migration system included.
- Great developer experience.

### TypeORM
- Popular with NestJS.
- More complex internals, sometimes fragile migrations.

### Sequelize
- Used for years in many projects.
- TypeScript support is less clean.
- Harder to maintain in large codebases.

## 5. Authentication

### JWT (Access + Refresh Tokens)
- Standard solution for mobile apps.
- Stateless -> no server‑side session storage.
- Easy to refresh tokens securely.
- Works perfectly with HTTPS.

## 6. API Style & Documentation

### REST API + Swagger
- Simple and predictable.
- Easy to test and reason about.
- Fully sufficient given BBP’s requirements.
- Easy for teammates to test endpoints.
- Clear documentation for ITD.
- Auto-generated by NestJS.

## 8. Deployment

### Dockerized Deployment + VPS
- Docker ensures consistent environment across developers.
- Easy to ship as containers: `api`, `postgres`.
- Deployment platforms handle builds automatically.

## 9. Project Configuration

### Initial Setup

```bash
# Initialize Node.js project with default settings
npm init -y 

# Install TypeScript and Node.js type definitions
npm install typescript @types/node @tsconfig/node24 -D
# @tsconfig/node24: Base TypeScript config optimized for Node.js 24

# Create tsconfig.json
# Configure: module=ESNext, target=ES2023, strict mode, outDir=dist

# Install Express.js framework
npm install express
npm install @types/express -D  # TypeScript definitions for Express

# Install development watcher (auto-restart on file changes)
npm install tsc-watch -D
# Configure scripts: 
#   - build: tsc (compile TypeScript)
#   - start: node ./dist/server.js (run compiled code)
#   - dev: tsc-watch --onSuccess "node ./dist/server.js" (watch mode)

# Install middleware
npm install cors morgan  # CORS & HTTP request logger
npm install @types/cors @types/morgan -D  # TypeScript definitions
```

### Prisma setup

- https://www.prisma.io/docs/
- https://www.prisma.io/docs/postgres (easy to go when you don't have a db, generous free tier, cloud based instance)
- https://www.prisma.io/docs/orm (local instance, you need an adapter to connect your existing db)


### Key Configuration Files

**tsconfig.json**
- `module: "ESNext"` - Modern ES modules
- `target: "ES2023"` - Latest JavaScript features
- `strict: true` - Enable all strict type checks
- `outDir: "./dist"` - Compiled output directory
- `rootDir: "./src"` - Source files location

**package.json**
- `"type": "module"` - Use ES modules instead of CommonJS
- Scripts for build, dev, and production modes

**prisma/schema.prisma**
- Database provider: PostgreSQL
- Models definition (User, Trip, Path, etc.)
- Relations between entities

**.env**
- `DATABASE_URL` - PostgreSQL connection string
- Other environment variables (JWT secrets, ports, etc.)

### Common Prisma Commands

```bash
# Development workflow
npx prisma migrate --create-only --name <migration_name>  # Create migration without applying, useful for review
npx prisma migrate dev --name <migration_name>  # Create & apply migration
npx prisma generate  # Regenerate Prisma Client after schema changes
npx prisma studio    # Open database GUI

# Production deployment
npx prisma migrate deploy  # Apply pending migrations (no interactive prompts)

# Database management
npx prisma migrate reset   # Reset database & reapply all migrations
npx prisma db push         # Sync schema without creating migration (prototyping)
```

### Project Structure

```bash
src/
├── middleware              # Middlewares
│   └── jwt.auth.ts        # JWT authentication middleware
│   └── http.logger.ts     # HTTP request logging middleware
│   └── ...                 # Other middlewares
├── errors/                 # Custom error classes
│   └── app.errors.ts     # Application-specific errors
├── prisma/                 # Prisma setup
│   └── schema.prisma       # Prisma schema file
│   └── migrations/         # Prisma migrations
├── managers/               # Business logic
│   └── user/...            # User-related logic
│   └── query/...           # Query-related logic
│   └── .../...             # Other related logic
├── routes/                 # API route definitions
│   └── v1/                 # Version 1 of the API
│       └── auth.routes.ts  # Authentication routes
│       └── user.routes.ts  # User routes
│       └── ...             # Other routes
│       └── index.ts        # Central router for v1
├── types/                  # TypeScript type definitions if needed i don't know
├── utils/                  # Utility functions
│   └── prisma-client.ts    # Prisma client instance
│   └── ...                 # Other utility functions
├── .env                    # Environment variables
├── tsconfig.json           # TypeScript configuration
├── prisma.config.ts        # Prisma configuration
├── package.json            # Package configuration
├── package.lock.json       # Package lock file
└── server.ts               # Server entry point
```
## 10. General notes

- an example of installing jsonwebtoken and its types:
```bash
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken
```
- Managers in our case are either controllers and business logic handlers. They handle requests, process data, and interact with the database via Prisma. All the managers use the query manager to perform database operations. Our case is a MVC like architecture where:
  - Models are represented by Prisma schema and generated client
  - Views are the API responses sent to clients
  - Controllers are the route handlers that use managers to process requests
- Route handlers should be kept thin, delegating most of the logic to managers
- In the types folder we can add custom types or interfaces if needed, useful for type safety and to see errors at compile time.
- Versioning the API (e.g., v1, v2) allows for backward compatibility and easier future updates
- Use async/await for all asynchronous operations to ensure non-blocking behavior
- Use environment variables for sensitive data and configuration settings
- Indexing database fields at the end of the development phase for performance optimization, once we have all the queries defined
- Custom error handling middleware implemented in order to catch and respond to errors consistently across the application
- Logging middleware using Pino for low overhead and high performance logging, accompanied also by a custom http logger
- TODO: Perform unit and integration testing using Jest